<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Entity Renderer</title>
    <style>
        body { margin: 0; background: transparent; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <script>
        // Get entity ID from URL
        const params = new URLSearchParams(window.location.search);
        const entityId = params.get('entity') || 'goblin';

        // ========== TEXTURES ==========
        function createSimpleTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            goblinSkin: createSimpleTexture('#5a8a5a'),
            goblinArmor: createSimpleTexture('#3a4a3a'),
            giantSkin: createSimpleTexture('#6a5a4a'),
            giantArmor: createSimpleTexture('#4a3a2a'),
            dragonScale: createSimpleTexture('#2a5a2a'),
        };

        // ========== ENTITY RENDERERS ==========
        const entityRenderers = {
            // MOBS
            'goblin': function() {
                const group = new THREE.Group();
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ map: textures.goblinArmor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                group.add(body);
                
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ map: textures.goblinSkin });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.5;
                group.add(head);
                
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.5, 0.35);
                    group.add(eye);
                });
                
                const earGeometry = new THREE.ConeGeometry(0.15, 0.4, 4);
                const earMaterial = new THREE.MeshLambertMaterial({ map: textures.goblinSkin });
                [-0.5, 0.5].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeometry, earMaterial);
                    ear.rotation.z = i === 0 ? Math.PI / 2 : -Math.PI / 2;
                    ear.position.set(x, 1.5, 0);
                    group.add(ear);
                });
                
                return group;
            },

            'goblin-christmas': function() {
                const group = new THREE.Group();
                const elfGreen = 0x228b22;          // Forest green for evil elf
                const elfRed = 0xcc0000;            // Christmas red
                const snowWhite = 0xffffff;         // Snow white
                const hatRed = 0xdc143c;            // Bright red for santa hat
                const goldBell = 0xffd700;          // Gold for bell
                
                // Body (green elf outfit)
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: elfGreen });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                group.add(body);
                
                // Red belt
                const beltGeometry = new THREE.BoxGeometry(0.65, 0.15, 0.42);
                const beltMaterial = new THREE.MeshLambertMaterial({ color: elfRed });
                const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                belt.position.y = 0.7;
                group.add(belt);
                
                // Gold belt buckle
                const buckleGeometry = new THREE.BoxGeometry(0.2, 0.12, 0.05);
                const buckleMaterial = new THREE.MeshLambertMaterial({ color: goldBell });
                const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
                buckle.position.set(0, 0.7, 0.23);
                group.add(buckle);
                
                // Head (green elf skin)
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: elfGreen });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.5;
                group.add(head);
                
                // Evil red eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.5, 0.35);
                    group.add(eye);
                });
                
                // Pointed elf ears (green)
                const earGeometry = new THREE.ConeGeometry(0.15, 0.4, 4);
                const earMaterial = new THREE.MeshLambertMaterial({ color: elfGreen });
                [-0.5, 0.5].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeometry, earMaterial);
                    ear.rotation.z = i === 0 ? Math.PI / 2 : -Math.PI / 2;
                    ear.position.set(x, 1.5, 0);
                    group.add(ear);
                });
                
                // Santa hat (red with white trim)
                const hatConeGeometry = new THREE.ConeGeometry(0.35, 0.6, 16);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: hatRed });
                const hatCone = new THREE.Mesh(hatConeGeometry, hatMaterial);
                hatCone.position.y = 2.1;
                hatCone.rotation.z = 0.3; // Tilt slightly
                group.add(hatCone);
                
                // Hat trim (white fur)
                const trimGeometry = new THREE.TorusGeometry(0.36, 0.08, 8, 16);
                const trimMaterial = new THREE.MeshLambertMaterial({ color: snowWhite });
                const trim = new THREE.Mesh(trimGeometry, trimMaterial);
                trim.position.y = 1.8;
                trim.rotation.x = Math.PI / 2;
                group.add(trim);
                
                // Hat pom-pom
                const pomGeometry = new THREE.SphereGeometry(0.12, 12, 12);
                const pom = new THREE.Mesh(pomGeometry, trimMaterial);
                pom.position.set(0.15, 2.5, 0);
                group.add(pom);
                
                // Red scarf
                const scarfGeometry = new THREE.TorusGeometry(0.3, 0.08, 8, 16);
                const scarfMaterial = new THREE.MeshLambertMaterial({ color: elfRed });
                const scarf = new THREE.Mesh(scarfGeometry, scarfMaterial);
                scarf.position.y = 1.2;
                scarf.rotation.x = Math.PI / 2;
                group.add(scarf);
                
                // Scarf tail
                const tailGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.08);
                const tail = new THREE.Mesh(tailGeometry, scarfMaterial);
                tail.position.set(0.25, 0.9, 0.1);
                tail.rotation.z = -0.3;
                group.add(tail);
                
                // Jingle bell on outfit
                const bellGeometry = new THREE.SphereGeometry(0.1, 12, 12);
                const bellMaterial = new THREE.MeshLambertMaterial({ color: goldBell });
                const bell = new THREE.Mesh(bellGeometry, bellMaterial);
                bell.position.set(0, 1.2, 0.35);
                group.add(bell);
                
                // Snow accents on shoulders
                const snowGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const snowMaterial = new THREE.MeshLambertMaterial({ color: snowWhite });
                [-0.35, 0.35].forEach(x => {
                    const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                    snow.position.set(x, 1.2, 0);
                    snow.scale.set(1, 0.5, 1);
                    group.add(snow);
                });
                
                return group;
            },

            'shark': function() {
                const group = new THREE.Group();
                const finGeometry = new THREE.ConeGeometry(0.5, 2.5, 3);
                const finMaterial = new THREE.MeshLambertMaterial({ color: 0x2a3a4a });
                const fin = new THREE.Mesh(finGeometry, finMaterial);
                fin.position.y = 1.0;
                group.add(fin);
                
                const detailGeometry = new THREE.ConeGeometry(0.15, 0.5, 3);
                const detail = new THREE.Mesh(detailGeometry, finMaterial);
                detail.position.set(0, 0.3, -0.4);
                group.add(detail);
                
                return group;
            },

            'devil': function() {
                const group = new THREE.Group();
                const devilRed = 0xCC2222;

                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.9, 0.4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: devilRed });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.85;
                group.add(body);

                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.55;
                group.add(head);

                const hornGeometry = new THREE.ConeGeometry(0.08, 0.5, 8);
                const hornMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                [[-0.25, 0.4], [0.25, -0.4]].forEach(([x, rot]) => {
                    const horn = new THREE.Mesh(hornGeometry, hornMaterial);
                    horn.position.set(x, 1.85, 0);
                    horn.rotation.z = rot;
                    group.add(horn);
                });

                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 12, 12);
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.55, 0.35);
                    group.add(eye);
                });

                const tailGeometry = new THREE.CylinderGeometry(0.05, 0.03, 0.8, 6);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.position.set(0, 0.5, -0.4);
                tail.rotation.x = 0.5;
                group.add(tail);

                return group;
            },

            'mummy': function() {
                const group = new THREE.Group();
                const bandageMaterial = new THREE.MeshLambertMaterial({ color: 0xd4c4a0 });
                
                // Wrapped body
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.6, 2.2, 12);
                const body = new THREE.Mesh(bodyGeometry, bandageMaterial);
                body.position.y = 1.3;
                group.add(body);
                
                // Bandage strips wrapping around body (darker contrasting color)
                for (let i = 0; i < 6; i++) {
                    const stripGeometry = new THREE.TorusGeometry(0.55, 0.06, 4, 16);
                    const stripMaterial = new THREE.MeshLambertMaterial({ color: 0x8a7a6a }); // Darker wraps for contrast
                    const strip = new THREE.Mesh(stripGeometry, stripMaterial);
                    strip.rotation.x = Math.PI / 2;
                    strip.rotation.z = i * 0.3;
                    strip.position.y = 0.5 + i * 0.35;
                    group.add(strip);
                }
                
                // Head wrapped in bandages
                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const head = new THREE.Mesh(headGeometry, bandageMaterial);
                head.position.y = 2.7;
                group.add(head);
                
                // Glowing eyes peeking through bandages
                const eyeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00FF88,
                    transparent: true
                });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                [-0.18, 0.18].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 2.75, 0.42);
                    group.add(eye);
                });
                
                // Arms (tattered bandage arms)
                const armGeometry = new THREE.CylinderGeometry(0.12, 0.15, 1.2, 8);
                const arm1 = new THREE.Mesh(armGeometry, bandageMaterial);
                arm1.position.set(-0.65, 1.5, 0);
                arm1.rotation.z = 0.3;
                group.add(arm1);
                
                const arm2 = new THREE.Mesh(armGeometry, bandageMaterial);
                arm2.position.set(0.65, 1.5, 0);
                arm2.rotation.z = -0.3;
                group.add(arm2);
                
                // Floating sand particles around mummy
                for (let i = 0; i < 8; i++) {
                    const sandGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                    const sandMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xc4a14a,
                        transparent: true,
                        opacity: 0.6
                    });
                    const sand = new THREE.Mesh(sandGeometry, sandMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    sand.position.set(Math.cos(angle) * 0.8, 1.5 + (i % 3) * 0.3, Math.sin(angle) * 0.8);
                    group.add(sand);
                }
                
                return group;
            },

            'guardian': function() {
                const group = new THREE.Group();
                
                const bodyGeometry = new THREE.BoxGeometry(0.8, 1.0, 0.5);
                const bodyMaterial = new THREE.MeshLambertMaterial({ map: textures.goblinArmor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.0;
                group.add(body);
                
                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ map: textures.goblinSkin });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                group.add(head);
                
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                const eyeGeometry = new THREE.SphereGeometry(0.12, 16, 16);
                [-0.18, 0.18].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.8, 0.42);
                    group.add(eye);
                });
                
                const earGeometry = new THREE.ConeGeometry(0.18, 0.5, 4);
                const earMaterial = new THREE.MeshLambertMaterial({ map: textures.goblinSkin });
                [-0.6, 0.6].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeometry, earMaterial);
                    ear.rotation.z = i === 0 ? Math.PI / 2 : -Math.PI / 2;
                    ear.position.set(x, 1.8, 0);
                    group.add(ear);
                });
                
                return group;
            },

            'guardian-christmas': function() {
                const group = new THREE.Group();
                const nutcrackerRed = 0xb22222;
                const nutcrackerGold = 0xffd700;
                const nutcrackerBlack = 0x111111;
                const nutcrackerWhite = 0xffffff;
                
                // Body - nutcracker soldier uniform
                const bodyGeometry = new THREE.BoxGeometry(0.8, 1.0, 0.5);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: nutcrackerRed });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.0;
                group.add(body);
                
                // Gold buttons on uniform
                for (let i = 0; i < 3; i++) {
                    const button = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16),
                        new THREE.MeshLambertMaterial({ color: nutcrackerGold })
                    );
                    button.rotation.x = Math.PI / 2;
                    button.position.set(0, 1.3 - i * 0.3, 0.28);
                    group.add(button);
                }
                
                // Head - wooden/painted look
                const headGeometry = new THREE.CylinderGeometry(0.4, 0.45, 0.6, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffc0a0 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.9;
                group.add(head);
                
                // Black eyes - nutcracker style
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: nutcrackerBlack });
                const eyeGeometry = new THREE.SphereGeometry(0.08, 12, 12);
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.95, 0.38);
                    group.add(eye);
                });
                
                // Tall nutcracker hat - black with gold trim
                const hatBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 0.15, 16),
                    new THREE.MeshLambertMaterial({ color: nutcrackerBlack })
                );
                hatBase.position.y = 2.3;
                group.add(hatBase);
                
                const hatTop = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35, 0.38, 0.8, 16),
                    new THREE.MeshLambertMaterial({ color: nutcrackerBlack })
                );
                hatTop.position.y = 2.75;
                group.add(hatTop);
                
                // Gold hat trim
                const hatTrim = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.39, 0.39, 0.1, 16),
                    new THREE.MeshLambertMaterial({ color: nutcrackerGold })
                );
                hatTrim.position.y = 2.38;
                group.add(hatTrim);
                
                // White beard/mustache
                const beard = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.25, 0.2),
                    new THREE.MeshLambertMaterial({ color: nutcrackerWhite })
                );
                beard.position.set(0, 1.75, 0.35);
                group.add(beard);
                
                // Red scarf around neck
                const scarf = new THREE.Mesh(
                    new THREE.TorusGeometry(0.5, 0.12, 8, 12, Math.PI),
                    new THREE.MeshLambertMaterial({ color: 0xff0000 })
                );
                scarf.rotation.x = Math.PI / 2;
                scarf.position.y = 1.5;
                group.add(scarf);
                
                // Snowy shoulder pads (snow accumulated on shoulders)
                [-0.45, 0.45].forEach(x => {
                    const snow = new THREE.Mesh(
                        new THREE.SphereGeometry(0.18, 12, 12),
                        new THREE.MeshLambertMaterial({ color: nutcrackerWhite })
                    );
                    snow.position.set(x, 1.55, 0);
                    snow.scale.y = 0.5;
                    group.add(snow);
                });
                
                return group;
            },

            'octopus': function() {
                const group = new THREE.Group();
                
                const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                bodyGeometry.scale(1, 1.2, 1);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B008B });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.2;
                group.add(body);

                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                const eyeGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                [-0.3, 0.3].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.4, 0.6);
                    group.add(eye);
                });

                const tentacleGeometry = new THREE.CylinderGeometry(0.12, 0.06, 1.5, 6);
                const tentacleMaterial = new THREE.MeshLambertMaterial({ color: 0x9932CC });
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const tentacle = new THREE.Mesh(tentacleGeometry, tentacleMaterial);
                    tentacle.position.set(Math.cos(angle) * 0.6, 0.3, Math.sin(angle) * 0.6);
                    tentacle.rotation.z = Math.cos(angle) * 0.3;
                    tentacle.rotation.x = Math.sin(angle) * 0.3;
                    group.add(tentacle);
                }
                
                return group;
            },

            'greater-devil': function() {
                const group = new THREE.Group();
                const devilRed = 0xAA1111;

                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.6, 1.3, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: devilRed });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.1;
                group.add(body);

                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 2.0;
                group.add(head);

                const hornGeometry = new THREE.ConeGeometry(0.12, 0.8, 8);
                const hornMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
                [[-0.35, 0.5], [0.35, -0.5]].forEach(([x, rot]) => {
                    const horn = new THREE.Mesh(hornGeometry, hornMaterial);
                    horn.position.set(x, 2.4, 0);
                    horn.rotation.z = rot;
                    group.add(horn);
                });

                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4400 });
                const eyeGeometry = new THREE.SphereGeometry(0.12, 12, 12);
                [-0.18, 0.18].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 2.0, 0.42);
                    group.add(eye);
                });

                const wingGeometry = new THREE.PlaneGeometry(1.2, 0.8);
                const wingMaterial = new THREE.MeshLambertMaterial({ color: 0x660000, side: THREE.DoubleSide });
                [[-0.8, 0.8], [0.8, -0.8]].forEach(([x, rot]) => {
                    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                    wing.position.set(x, 1.5, -0.2);
                    wing.rotation.y = rot;
                    group.add(wing);
                });

                return group;
            },

            'giant': function() {
                const group = new THREE.Group();
                
                const bodyGeometry = new THREE.CylinderGeometry(1.5, 1.8, 5.0, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ map: textures.giantSkin });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 3.5;
                group.add(body);
                
                // Armor plates
                const plateGeometry = new THREE.BoxGeometry(2.0, 0.4, 2.2);
                const plateMaterial = new THREE.MeshLambertMaterial({ map: textures.giantArmor });
                for (let i = 0; i < 4; i++) {
                    const plate = new THREE.Mesh(plateGeometry, plateMaterial);
                    plate.position.y = 2.0 + (i * 1.2);
                    group.add(plate);
                }
                
                const headGeometry = new THREE.BoxGeometry(1.8, 1.5, 1.6);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 6.5;
                group.add(head);
                
                const hornGeometry = new THREE.ConeGeometry(0.3, 1.2, 6);
                const hornMaterial = new THREE.MeshLambertMaterial({ map: textures.giantArmor });
                [[-0.9, -0.3], [0.9, 0.3]].forEach(([x, rot]) => {
                    const horn = new THREE.Mesh(hornGeometry, hornMaterial);
                    horn.position.set(x, 7.5, 0);
                    horn.rotation.z = rot;
                    group.add(horn);
                });
                
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff8800 });
                const eyeGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                [-0.5, 0.5].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 6.5, 0.9);
                    group.add(eye);
                });
                
                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.4, 0.8, 4.0, 8);
                const armMaterial = new THREE.MeshLambertMaterial({ map: textures.giantSkin });
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-2.2, 4.0, 0);
                leftArm.rotation.z = 0.3;
                group.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(2.2, 4.0, 0);
                rightArm.rotation.z = -0.3;
                group.add(rightArm);
                
                // Fists
                const fistGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const fistMaterial = new THREE.MeshLambertMaterial({ map: textures.giantSkin });
                const leftFist = new THREE.Mesh(fistGeometry, fistMaterial);
                leftFist.position.set(-2.8, 1.8, 0);
                group.add(leftFist);
                
                const rightFist = new THREE.Mesh(fistGeometry, fistMaterial);
                rightFist.position.set(2.8, 1.8, 0);
                group.add(rightFist);
                
                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.7, 0.9, 3.5, 8);
                const leftLeg = new THREE.Mesh(legGeometry, armMaterial);
                leftLeg.position.set(-0.9, 1.2, 0);
                group.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(legGeometry, armMaterial);
                rightLeg.position.set(0.9, 1.2, 0);
                group.add(rightLeg);
                
                return group;
            },

            'wizard': function() {
                const group = new THREE.Group();
                
                const bodyGeometry = new THREE.CylinderGeometry(0.6, 1.0, 2.5, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4466aa });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                group.add(body);
                
                const headGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xaaccff });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.0;
                group.add(head);
                
                const hatGeometry = new THREE.ConeGeometry(0.7, 1.5, 8);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: 0x3355aa });
                const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                hat.position.y = 4.0;
                group.add(hat);
                
                const brimGeometry = new THREE.TorusGeometry(0.75, 0.15, 8, 16);
                const brim = new THREE.Mesh(brimGeometry, hatMaterial);
                brim.rotation.x = Math.PI / 2;
                brim.position.y = 3.4;
                group.add(brim);
                
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
                const eyeGeometry = new THREE.SphereGeometry(0.12, 16, 16);
                [-0.22, 0.22].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 3.0, 0.52);
                    group.add(eye);
                });
                
                const staffGeometry = new THREE.CylinderGeometry(0.06, 0.08, 3.0, 8);
                const staffMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                staff.position.set(0.8, 1.5, 0.3);
                staff.rotation.z = -0.2;
                group.add(staff);
                
                const orbGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.set(0.9, 3.2, 0.3);
                group.add(orb);
                
                return group;
            },

            'wizard-christmas': function() {
                const group = new THREE.Group();
                
                // Red Santa coat
                const bodyGeometry = new THREE.CylinderGeometry(0.6, 1.0, 2.5, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                group.add(body);
                
                // White fur trim on coat
                const trimGeometry = new THREE.CylinderGeometry(1.02, 1.02, 0.3, 12);
                const trimMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const trim = new THREE.Mesh(trimGeometry, trimMaterial);
                trim.position.y = 0.4;
                group.add(trim);
                
                // Belt
                const beltGeometry = new THREE.CylinderGeometry(1.01, 1.01, 0.25, 12);
                const beltMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                belt.position.y = 1.5;
                group.add(belt);
                
                // Gold belt buckle
                const buckleGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.1);
                const buckleMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
                buckle.position.set(0, 1.5, 1.05);
                group.add(buckle);
                
                // Head with pale skin
                const headGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.0;
                group.add(head);
                
                // White beard
                const beardGeometry = new THREE.SphereGeometry(0.55, 16, 12);
                beardGeometry.scale(1.0, 0.8, 0.9);
                const beardMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const beard = new THREE.Mesh(beardGeometry, beardMaterial);
                beard.position.set(0, 2.7, 0.3);
                group.add(beard);
                
                // Red Santa hat
                const hatGeometry = new THREE.ConeGeometry(0.7, 1.5, 8);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
                const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                hat.position.y = 4.0;
                group.add(hat);
                
                // White fur trim on hat
                const hatTrimGeometry = new THREE.TorusGeometry(0.72, 0.15, 8, 16);
                const hatTrim = new THREE.Mesh(hatTrimGeometry, trimMaterial);
                hatTrim.rotation.x = Math.PI / 2;
                hatTrim.position.y = 3.4;
                group.add(hatTrim);
                
                // White pompom on hat
                const pompomGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                const pompom = new THREE.Mesh(pompomGeometry, trimMaterial);
                pompom.position.y = 4.75;
                group.add(pompom);
                
                // Dark evil eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const eyeGeometry = new THREE.SphereGeometry(0.12, 16, 16);
                [-0.22, 0.22].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 3.1, 0.52);
                    group.add(eye);
                });
                
                // Candy cane staff instead of wizard staff
                const staffGeometry = new THREE.CylinderGeometry(0.08, 0.08, 3.0, 8);
                const staffMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                staff.position.set(0.8, 1.5, 0.3);
                staff.rotation.z = -0.2;
                group.add(staff);
                
                // Red stripes on candy cane
                for (let i = 0; i < 6; i++) {
                    const stripeGeometry = new THREE.CylinderGeometry(0.09, 0.09, 0.3, 8);
                    const stripeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.set(0.8, 0.5 + i * 0.5, 0.3);
                    stripe.rotation.z = -0.2;
                    group.add(stripe);
                }
                
                // Curved top of candy cane
                const caneTopGeometry = new THREE.TorusGeometry(0.3, 0.08, 8, 16, Math.PI);
                const caneTop = new THREE.Mesh(caneTopGeometry, staffMaterial);
                caneTop.rotation.z = Math.PI / 2 - 0.2;
                caneTop.position.set(0.85, 3.2, 0.3);
                group.add(caneTop);
                
                // Red glowing ornament orb
                const orbGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.set(0.55, 3.2, 0.3);
                group.add(orb);
                
                return group;
            },

            'lava-monster': function() {
                const group = new THREE.Group();
                
                const torsoGeometry = new THREE.SphereGeometry(1.0, 16, 12);
                torsoGeometry.scale(1.0, 1.3, 0.9);
                const torsoMaterial = new THREE.MeshBasicMaterial({ color: 0xff3300, transparent: true, opacity: 0.9 });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 2.2;
                group.add(torso);
                
                const shellGeometry = new THREE.DodecahedronGeometry(1.25, 1);
                shellGeometry.scale(1.0, 1.3, 0.9);
                const shellMaterial = new THREE.MeshLambertMaterial({ color: 0x1a0a05, transparent: true, opacity: 0.75 });
                const shell = new THREE.Mesh(shellGeometry, shellMaterial);
                shell.position.y = 2.2;
                group.add(shell);
                
                const headGeometry = new THREE.DodecahedronGeometry(0.6, 0);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0x2a1208 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.5;
                group.add(head);
                
                // Head glow
                const headGlowGeometry = new THREE.DodecahedronGeometry(0.55, 0);
                const headGlowMaterial = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.6 });
                const headGlow = new THREE.Mesh(headGlowGeometry, headGlowMaterial);
                headGlow.position.y = 3.5;
                group.add(headGlow);
                
                const hornMaterial = new THREE.MeshLambertMaterial({ color: 0x1a0805 });
                const hornGeometry = new THREE.ConeGeometry(0.15, 0.6, 6);
                [[-0.35, 0.4], [0.35, -0.4]].forEach(([x, rot]) => {
                    const horn = new THREE.Mesh(hornGeometry, hornMaterial);
                    horn.position.set(x, 3.9, 0);
                    horn.rotation.z = rot;
                    group.add(horn);
                });
                
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const eyeGeometry = new THREE.SphereGeometry(0.18, 12, 12);
                eyeGeometry.scale(1.3, 0.7, 1);
                [-0.25, 0.25].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 3.55, 0.45);
                    group.add(eye);
                });
                
                // Mouth
                const mouthGeometry = new THREE.BoxGeometry(0.5, 0.15, 0.2);
                const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0xff2200, transparent: true, opacity: 0.9 });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 3.25, 0.5);
                group.add(mouth);
                
                // Arms with hands
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x2a1510 });
                const armGlowMaterial = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.7 });
                
                // Left arm group
                const leftArmGroup = new THREE.Group();
                const leftUpperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 1.0, 8), armMaterial);
                leftUpperArm.position.y = -0.3;
                leftUpperArm.rotation.z = 0.5;
                leftArmGroup.add(leftUpperArm);
                
                const leftForearm = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.9, 8), armMaterial);
                leftForearm.position.set(-0.4, -0.9, 0);
                leftForearm.rotation.z = 0.3;
                leftArmGroup.add(leftForearm);
                
                const leftHand = new THREE.Mesh(new THREE.DodecahedronGeometry(0.25, 0), armMaterial);
                leftHand.position.set(-0.6, -1.5, 0);
                leftArmGroup.add(leftHand);
                
                const leftArmGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.6, 6), armGlowMaterial);
                leftArmGlow.position.set(-0.2, -0.6, 0);
                leftArmGlow.rotation.z = 0.4;
                leftArmGroup.add(leftArmGlow);
                
                leftArmGroup.position.set(-1.1, 2.5, 0);
                group.add(leftArmGroup);
                
                // Right arm group (mirrored)
                const rightArmGroup = new THREE.Group();
                const rightUpperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 1.0, 8), armMaterial);
                rightUpperArm.position.y = -0.3;
                rightUpperArm.rotation.z = -0.5;
                rightArmGroup.add(rightUpperArm);
                
                const rightForearm = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.9, 8), armMaterial);
                rightForearm.position.set(0.4, -0.9, 0);
                rightForearm.rotation.z = -0.3;
                rightArmGroup.add(rightForearm);
                
                const rightHand = new THREE.Mesh(new THREE.DodecahedronGeometry(0.25, 0), armMaterial);
                rightHand.position.set(0.6, -1.5, 0);
                rightArmGroup.add(rightHand);
                
                const rightArmGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.6, 6), armGlowMaterial);
                rightArmGlow.position.set(0.2, -0.6, 0);
                rightArmGlow.rotation.z = -0.4;
                rightArmGroup.add(rightArmGlow);
                
                rightArmGroup.position.set(1.1, 2.5, 0);
                group.add(rightArmGroup);
                
                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8);
                const leftLeg = new THREE.Mesh(legGeometry, armMaterial);
                leftLeg.position.set(-0.5, 0.5, 0);
                group.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(legGeometry, armMaterial);
                rightLeg.position.set(0.5, 0.5, 0);
                group.add(rightLeg);
                
                // Feet
                const footGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.6);
                const leftFoot = new THREE.Mesh(footGeometry, armMaterial);
                leftFoot.position.set(-0.5, -0.1, 0.1);
                group.add(leftFoot);
                
                const rightFoot = new THREE.Mesh(footGeometry, armMaterial);
                rightFoot.position.set(0.5, -0.1, 0.1);
                group.add(rightFoot);
                
                return group;
            },

            'dragon': function() {
                const group = new THREE.Group();
                const dragonColor = 0x2a5a2a;
                
                // Body - long segmented shape
                const bodyGeometry = new THREE.CylinderGeometry(2, 2.5, 10, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: dragonColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                body.position.x = 5;
                group.add(body);
                
                // Body scales/spines
                for (let i = 0; i < 8; i++) {
                    const scaleGeometry = new THREE.ConeGeometry(0.6, 1.2, 6);
                    const scale = new THREE.Mesh(scaleGeometry, bodyMaterial);
                    scale.position.set(i * 1.2, 2.8, 0);
                    scale.rotation.z = 0;
                    group.add(scale);
                }
                
                // Neck
                const neckGeometry = new THREE.CylinderGeometry(1.8, 2, 4, 8);
                const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
                neck.rotation.z = Math.PI / 2;
                neck.position.x = 10;
                neck.position.y = 1;
                group.add(neck);
                
                // Head - cone shape
                const headGeometry = new THREE.ConeGeometry(2.5, 5, 8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.rotation.z = -Math.PI / 2;
                head.position.x = 13;
                head.position.y = 1.5;
                group.add(head);
                
                // Jaw
                const jawGeometry = new THREE.BoxGeometry(2, 1.5, 2);
                const jaw = new THREE.Mesh(jawGeometry, bodyMaterial);
                jaw.position.set(14, 0.5, 0);
                group.add(jaw);
                
                // Teeth
                for (let i = 0; i < 6; i++) {
                    const toothGeometry = new THREE.ConeGeometry(0.15, 0.6, 4);
                    const toothMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                    const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                    tooth.position.set(14 + (i % 2) * 0.5, 1.2, -1 + i * 0.4);
                    tooth.rotation.z = Math.PI;
                    group.add(tooth);
                }
                
                // Eyes - glowing
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                const eyeGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                [-1.2, 1.2].forEach(z => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(13.5, 2.5, z);
                    group.add(eye);
                });
                
                // Horns
                const hornGeometry = new THREE.ConeGeometry(0.5, 2.5, 6);
                const hornMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
                [-1.5, 1.5].forEach((z, i) => {
                    const horn = new THREE.Mesh(hornGeometry, hornMaterial);
                    horn.position.set(12.5, 4, z);
                    horn.rotation.z = -0.4;
                    horn.rotation.x = i === 0 ? 0.2 : -0.2;
                    group.add(horn);
                });
                
                // Wings - triangular shape
                const wingGeometry = new THREE.BufferGeometry();
                const wingVertices = new Float32Array([
                    0, 0, 0,
                    6, 2, 0,
                    8, 0, 0,
                    6, -2, 0,
                    4, -1, 0
                ]);
                wingGeometry.setAttribute('position', new THREE.BufferAttribute(wingVertices, 3));
                wingGeometry.setIndex([0, 1, 2, 0, 2, 3, 0, 3, 4]);
                wingGeometry.computeVertexNormals();
                const wingMaterial = new THREE.MeshLambertMaterial({ color: dragonColor, side: THREE.DoubleSide });
                
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(3, 3, 0);
                leftWing.rotation.y = Math.PI / 2;
                group.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(3, 3, 0);
                rightWing.rotation.y = -Math.PI / 2;
                group.add(rightWing);
                
                // Tail segments
                for (let i = 0; i < 3; i++) {
                    const segmentGeometry = new THREE.CylinderGeometry(1.5 - i * 0.3, 1.8 - i * 0.3, 3, 8);
                    const segment = new THREE.Mesh(segmentGeometry, bodyMaterial);
                    segment.rotation.z = Math.PI / 2;
                    segment.position.x = -3 - i * 2.5;
                    segment.position.y = 0.5 - i * 0.3;
                    group.add(segment);
                }
                
                // Tail spikes
                for (let i = 0; i < 10; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.3, 1, 6);
                    const spike = new THREE.Mesh(spikeGeometry, bodyMaterial);
                    spike.position.set(-i * 0.8, 2.5, 0);
                    spike.rotation.z = Math.PI;
                    group.add(spike);
                }
                
                // Belly
                const bellyGeometry = new THREE.CylinderGeometry(1.8, 2.2, 8, 12);
                const bellyMaterial = new THREE.MeshLambertMaterial({ color: 0x4a6a4a });
                const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
                belly.rotation.z = Math.PI / 2;
                belly.position.set(5, -1, 0);
                group.add(belly);
                
                return group;
            },

            'bird': function() {
                const group = new THREE.Group();
                
                const bodyGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                const wingGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.4);
                const wingMaterial = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
                [[-0.6, 0.3], [0.6, -0.3]].forEach(([x, rot]) => {
                    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                    wing.position.set(x, 0, 0);
                    wing.rotation.z = rot;
                    group.add(wing);
                });
                
                const beakGeometry = new THREE.ConeGeometry(0.15, 0.3, 6);
                const beakMaterial = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
                const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                beak.rotation.z = -Math.PI / 2;
                beak.position.set(0, 0, -0.4);
                group.add(beak);
                
                return group;
            },

            'pirate-ship': function() {
                const group = new THREE.Group();

                const hullGeometry = new THREE.BoxGeometry(8, 3, 20);
                const hullMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
                const hull = new THREE.Mesh(hullGeometry, hullMaterial);
                hull.position.y = 1.5;
                group.add(hull);

                const deckGeometry = new THREE.BoxGeometry(7, 0.5, 18);
                const deckMaterial = new THREE.MeshLambertMaterial({ color: 0x6a5040 });
                const deck = new THREE.Mesh(deckGeometry, deckMaterial);
                deck.position.y = 3;
                group.add(deck);

                const mastGeometry = new THREE.CylinderGeometry(0.3, 0.4, 12, 8);
                const mastMaterial = new THREE.MeshLambertMaterial({ color: 0x3a2510 });
                const mast = new THREE.Mesh(mastGeometry, mastMaterial);
                mast.position.y = 9;
                group.add(mast);

                const sailGeometry = new THREE.PlaneGeometry(6, 8);
                const sailMaterial = new THREE.MeshLambertMaterial({ color: 0x111111, side: THREE.DoubleSide });
                const sail = new THREE.Mesh(sailGeometry, sailMaterial);
                sail.position.y = 10;
                sail.position.z = 0.5;
                group.add(sail);

                return group;
            },

            // ITEMS
            'ammo': function() {
                const group = new THREE.Group();
                
                // Brown ammo box
                const boxGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.4);
                const boxMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const ammoBox = new THREE.Mesh(boxGeometry, boxMaterial);
                ammoBox.position.y = 0.3;
                group.add(ammoBox);
                
                // Yellow stripe/mark
                const markGeometry = new THREE.BoxGeometry(0.61, 0.15, 0.41);
                const markMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFFFF00,
                    emissive: 0xFFAA00,
                    emissiveIntensity: 0.3
                });
                const mark = new THREE.Mesh(markGeometry, markMaterial);
                mark.position.y = 0.3;
                group.add(mark);
                
                // Glow effect
                const glowGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFF00, 
                    transparent: true, 
                    opacity: 0.25 
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 0.3;
                group.add(glow);
                
                return group;
            },

            'health': function() {
                const group = new THREE.Group();
                const heartMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0066 });
                
                const sphereGeom = new THREE.SphereGeometry(0.4, 16, 16);
                [-0.3, 0.3].forEach(x => {
                    const sphere = new THREE.Mesh(sphereGeom, heartMaterial);
                    sphere.position.set(x, 0.8, 0);
                    group.add(sphere);
                });
                
                const coneGeom = new THREE.ConeGeometry(0.55, 1.0, 8);
                const cone = new THREE.Mesh(coneGeom, heartMaterial);
                cone.rotation.x = Math.PI;
                cone.position.y = 0.3;
                group.add(cone);
                
                return group;
            },

            'bomb': function() {
                const group = new THREE.Group();
                const bombGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bombMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const bomb = new THREE.Mesh(bombGeometry, bombMaterial);
                bomb.position.y = 0.5;
                group.add(bomb);
                
                const fuseGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 6);
                const fuseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const fuse = new THREE.Mesh(fuseGeometry, fuseMaterial);
                fuse.position.y = 1.0;
                fuse.rotation.z = 0.3;
                group.add(fuse);
                
                const sparkGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const sparkMaterial = new THREE.MeshBasicMaterial({ color: 0xFFAA00 });
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                spark.position.y = 1.25;
                spark.position.x = 0.1;
                group.add(spark);
                
                return group;
            },

            'material': function() {
                const group = new THREE.Group();
                const plankGeometry = new THREE.BoxGeometry(0.3, 0.1, 1.5);
                const plankMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                for (let i = 0; i < 3; i++) {
                    const plank = new THREE.Mesh(plankGeometry, plankMaterial);
                    plank.position.set((i - 1) * 0.35, 0.3, 0);
                    plank.rotation.z = (Math.random() - 0.5) * 0.2;
                    group.add(plank);
                }
                
                return group;
            },

            'kite': function() {
                const group = new THREE.Group();
                const kiteGeometry = new THREE.ConeGeometry(0.8, 1.2, 4);
                const kiteMaterial = new THREE.MeshLambertMaterial({ color: 0xFF1493 });
                const kite = new THREE.Mesh(kiteGeometry, kiteMaterial);
                kite.rotation.x = Math.PI;
                kite.position.y = 1.2;
                group.add(kite);
                
                const tailGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 4);
                const tailMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.y = 0.0;
                group.add(tail);
                
                return group;
            },

            'iceberg': function() {
                const group = new THREE.Group();
                const iceBergGeometry = new THREE.ConeGeometry(2, 5, 6);
                const iceBergMaterial = new THREE.MeshPhongMaterial({
                    color: 0xB0E0E6,
                    transparent: true,
                    opacity: 0.7,
                    shininess: 100,
                    specular: 0xFFFFFF
                });
                const ice = new THREE.Mesh(iceBergGeometry, iceBergMaterial);
                ice.position.y = 2.5;
                group.add(ice);
                
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const crystalGeometry = new THREE.ConeGeometry(0.5, 2, 6);
                    const crystal = new THREE.Mesh(crystalGeometry, iceBergMaterial);
                    crystal.position.set(Math.cos(angle) * 1.5, 1, Math.sin(angle) * 1.5);
                    crystal.rotation.z = (Math.random() - 0.5) * 0.3;
                    group.add(crystal);
                }
                
                return group;
            },

            'scarab': function() {
                const group = new THREE.Group();
                
                const bodyGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                bodyGeometry.scale(1.2, 0.6, 1);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.3;
                group.add(body);
                
                const headGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.set(0, 0.3, 0.4);
                group.add(head);
                
                const glowGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.3 });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 0.3;
                group.add(glow);
                
                return group;
            },

            'treasure': function() {
                const group = new THREE.Group();
                const chestMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                const chestBottomGeometry = new THREE.BoxGeometry(1, 0.6, 0.8);
                const chestBottom = new THREE.Mesh(chestBottomGeometry, chestMaterial);
                chestBottom.position.y = 0.3;
                group.add(chestBottom);

                const chestLidGeometry = new THREE.BoxGeometry(1, 0.4, 0.8);
                const chestLid = new THREE.Mesh(chestLidGeometry, chestMaterial);
                chestLid.position.y = 0.8;
                chestLid.position.z = -0.3;
                chestLid.rotation.x = -Math.PI / 3;
                group.add(chestLid);

                const goldMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700, emissive: 0xFFAA00, emissiveIntensity: 0.5 });
                const goldPileGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const goldPile = new THREE.Mesh(goldPileGeometry, goldMaterial);
                goldPile.position.y = 0.7;
                group.add(goldPile);
                
                return group;
            },

            'herzman': function() {
                const group = new THREE.Group();
                
                // Base platform (cute pink pedestal)
                const baseGeometry = new THREE.CylinderGeometry(0.5, 0.7, 0.2, 16);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.1;
                group.add(base);
                
                // Main heart body using 3D shape (extruded heart)
                const heartShape = new THREE.Shape();
                heartShape.moveTo(0, 0.4);
                heartShape.bezierCurveTo(0, 0.5, -0.1, 0.6, -0.3, 0.6);
                heartShape.bezierCurveTo(-0.5, 0.6, -0.5, 0.3, -0.5, 0.3);
                heartShape.bezierCurveTo(-0.5, 0.1, -0.3, -0.1, 0, -0.3);
                heartShape.bezierCurveTo(0.3, -0.1, 0.5, 0.1, 0.5, 0.3);
                heartShape.bezierCurveTo(0.5, 0.3, 0.5, 0.6, 0.3, 0.6);
                heartShape.bezierCurveTo(0.1, 0.6, 0, 0.5, 0, 0.4);
                
                const extrudeSettings = { depth: 0.4, bevelEnabled: true, bevelSegments: 3, bevelSize: 0.08, bevelThickness: 0.08 };
                const heartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
                const heartMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFF1493,
                    emissive: 0xFF1493,
                    emissiveIntensity: 0.2
                });
                const heartBody = new THREE.Mesh(heartGeometry, heartMaterial);
                heartBody.position.set(0, 1.0, -0.2);
                heartBody.scale.set(1.8, 1.8, 1.8);
                group.add(heartBody);
                
                // Eyes (cute round eyes)
                const eyeGeometry = new THREE.SphereGeometry(0.12, 12, 12);
                const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                const eyeLeft = new THREE.Mesh(eyeGeometry, eyeWhiteMaterial);
                eyeLeft.position.set(-0.25, 1.35, 0.65);
                group.add(eyeLeft);
                
                const eyeRight = new THREE.Mesh(eyeGeometry, eyeWhiteMaterial);
                eyeRight.position.set(0.25, 1.35, 0.65);
                group.add(eyeRight);
                
                // Pupils
                const pupilGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const pupilLeft = new THREE.Mesh(pupilGeometry, pupilMaterial);
                pupilLeft.position.set(-0.25, 1.35, 0.76);
                group.add(pupilLeft);
                
                const pupilRight = new THREE.Mesh(pupilGeometry, pupilMaterial);
                pupilRight.position.set(0.25, 1.35, 0.76);
                group.add(pupilRight);
                
                // Cute blush cheeks
                const blushGeometry = new THREE.CircleGeometry(0.1, 12);
                const blushMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF6B6B, 
                    transparent: true, 
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const blush1 = new THREE.Mesh(blushGeometry, blushMaterial);
                blush1.position.set(-0.45, 1.15, 0.6);
                blush1.rotation.y = -0.3;
                group.add(blush1);
                
                const blush2 = new THREE.Mesh(blushGeometry, blushMaterial);
                blush2.position.set(0.45, 1.15, 0.6);
                blush2.rotation.y = 0.3;
                group.add(blush2);
                
                // Happy smile
                const smileGeometry = new THREE.TorusGeometry(0.15, 0.03, 8, 16, Math.PI);
                const smileMaterial = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
                const smile = new THREE.Mesh(smileGeometry, smileMaterial);
                smile.position.set(0, 1.05, 0.7);
                smile.rotation.x = Math.PI;
                group.add(smile);
                
                return group;
            },

            'banana': function() {
                const group = new THREE.Group();
                
                // Banana body (curved cylinder)
                const bananaGeometry = new THREE.CylinderGeometry(0.4, 0.4, 2.0, 8);
                const bananaMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFFFF00,
                    emissive: 0xFFFF00,
                    emissiveIntensity: 0.3
                });
                const bananaMesh = new THREE.Mesh(bananaGeometry, bananaMaterial);
                bananaMesh.rotation.z = Math.PI / 5; // Slight curve
                bananaMesh.position.y = 1.0;
                group.add(bananaMesh);
                
                // Banana ends (darker brown tips)
                const endMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7500 });
                const endGeometry = new THREE.SphereGeometry(0.45, 8, 8);
                const end1 = new THREE.Mesh(endGeometry, endMaterial);
                end1.position.set(0.35, 1.85, 0);
                end1.scale.set(0.7, 1.2, 0.7);
                group.add(end1);
                
                const end2 = new THREE.Mesh(endGeometry, endMaterial);
                end2.position.set(-0.35, 0.15, 0);
                end2.scale.set(0.7, 1.2, 0.7);
                group.add(end2);
                
                // Brown stem at top
                const stemGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.3, 6);
                const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3000 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.set(0.4, 2.1, 0);
                stem.rotation.z = -Math.PI / 6;
                group.add(stem);
                
                return group;
            },

            'portal': function() {
                const group = new THREE.Group();
                
                // Outer ring (cyan)
                const portalRingGeometry = new THREE.TorusGeometry(3, 0.3, 16, 48);
                const portalRingMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const portalRing = new THREE.Mesh(portalRingGeometry, portalRingMaterial);
                portalRing.rotation.x = Math.PI / 2;
                group.add(portalRing);
                
                // Inner ring (magenta)
                const portalInnerRingGeometry = new THREE.TorusGeometry(2.2, 0.2, 16, 48);
                const portalInnerRingMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff00ff,
                    emissive: 0xff00ff,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.8
                });
                const portalInnerRing = new THREE.Mesh(portalInnerRingGeometry, portalInnerRingMaterial);
                portalInnerRing.rotation.x = Math.PI / 2;
                group.add(portalInnerRing);
                
                // Portal center (purple swirl)
                const portalCenterGeometry = new THREE.CircleGeometry(2, 32);
                const portalCenterMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x8800ff, 
                    transparent: true, 
                    opacity: 0.6, 
                    side: THREE.DoubleSide 
                });
                const portalCenter = new THREE.Mesh(portalCenterGeometry, portalCenterMaterial);
                portalCenter.rotation.x = Math.PI / 2;
                portalCenter.position.y = 0.1;
                group.add(portalCenter);
                
                // Portal base glow
                const portalGlowGeometry = new THREE.CylinderGeometry(4, 4, 0.2, 32);
                const portalGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x4400aa,
                    transparent: true,
                    opacity: 0.4
                });
                const portalGlow = new THREE.Mesh(portalGlowGeometry, portalGlowMaterial);
                portalGlow.position.y = 0.1;
                group.add(portalGlow);
                
                // Portal pillars
                const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.4, 5, 8);
                const pillarMaterial = new THREE.MeshPhongMaterial({
                    color: 0x6600cc,
                    emissive: 0x220044,
                    emissiveIntensity: 0.4
                });
                
                const leftPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                leftPillar.position.set(-3.5, 2.5, 0);
                group.add(leftPillar);
                
                const rightPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                rightPillar.position.set(3.5, 2.5, 0);
                group.add(rightPillar);
                
                // Pillar top orbs
                const orbGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const orbMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.9
                });
                
                const leftOrb = new THREE.Mesh(orbGeometry, orbMaterial);
                leftOrb.position.set(-3.5, 5.3, 0);
                group.add(leftOrb);
                
                const rightOrb = new THREE.Mesh(orbGeometry, orbMaterial);
                rightOrb.position.set(3.5, 5.3, 0);
                group.add(rightOrb);
                
                // Floating particles
                for (let i = 0; i < 8; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: i % 2 === 0 ? 0x00ffff : 0xff00ff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    particle.position.set(Math.cos(angle) * 2.5, 1 + (i % 3) * 0.5, Math.sin(angle) * 2.5);
                    group.add(particle);
                }
                
                return group;
            },

            // HAZARDS
            'trap': function() {
                const group = new THREE.Group();
                const trapGeometry = new THREE.PlaneGeometry(2, 2);
                const trapMaterial = new THREE.MeshLambertMaterial({ color: 0x6a8a6a });
                const trap = new THREE.Mesh(trapGeometry, trapMaterial);
                trap.rotation.x = -Math.PI / 2;
                trap.position.y = 0.02;
                group.add(trap);
                
                for (let i = 0; i < 4; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.1, 0.4, 4);
                    const spikeMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    spike.position.set((i % 2 - 0.5) * 1.2, 0.2, (Math.floor(i / 2) - 0.5) * 1.2);
                    group.add(spike);
                }
                
                return group;
            },

            'whirlpool': function() {
                const group = new THREE.Group();
                
                const outerRingGeometry = new THREE.RingGeometry(1.5, 2.5, 24);
                const outerRingMaterial = new THREE.MeshBasicMaterial({ color: 0x104080, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
                const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
                outerRing.rotation.x = -Math.PI / 2;
                outerRing.position.y = 0.1;
                group.add(outerRing);

                const midRingGeometry = new THREE.RingGeometry(0.8, 1.5, 24);
                const midRingMaterial = new THREE.MeshBasicMaterial({ color: 0x1060a0, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const midRing = new THREE.Mesh(midRingGeometry, midRingMaterial);
                midRing.rotation.x = -Math.PI / 2;
                midRing.position.y = 0.05;
                group.add(midRing);

                const innerGeometry = new THREE.CircleGeometry(0.8, 24);
                const innerMaterial = new THREE.MeshBasicMaterial({ color: 0x000020 });
                const inner = new THREE.Mesh(innerGeometry, innerMaterial);
                inner.rotation.x = -Math.PI / 2;
                inner.position.y = 0.02;
                group.add(inner);
                
                return group;
            },

            'waterspout': function() {
                const group = new THREE.Group();
                
                const coneHeight = 10;
                const coneRadius = 2;
                const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16, 6, true);
                const coneMaterial = new THREE.MeshBasicMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                const outerCone = new THREE.Mesh(coneGeometry, coneMaterial);
                outerCone.rotation.x = Math.PI;
                outerCone.position.y = coneHeight / 2;
                group.add(outerCone);

                const innerConeGeometry = new THREE.ConeGeometry(coneRadius * 0.5, coneHeight * 0.8, 16, 6, true);
                const innerConeMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                const innerCone = new THREE.Mesh(innerConeGeometry, innerConeMaterial);
                innerCone.rotation.x = Math.PI;
                innerCone.position.y = coneHeight * 0.4;
                group.add(innerCone);
                
                return group;
            },

            'lava-pool': function() {
                const group = new THREE.Group();
                
                const poolGeometry = new THREE.CircleGeometry(2, 32);
                const poolMaterial = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.95 });
                const pool = new THREE.Mesh(poolGeometry, poolMaterial);
                pool.rotation.x = -Math.PI / 2;
                pool.position.y = 0.1;
                group.add(pool);

                const coreGeometry = new THREE.CircleGeometry(1.2, 32);
                const coreMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9 });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.rotation.x = -Math.PI / 2;
                core.position.y = 0.15;
                group.add(core);

                const centerGeometry = new THREE.CircleGeometry(0.5, 32);
                const centerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.rotation.x = -Math.PI / 2;
                center.position.y = 0.2;
                group.add(center);
                
                return group;
            },

            // ENVIRONMENT
            'rainbow': function() {
                const group = new THREE.Group();
                
                // Rainbow arcs - matching game: radius 5-(i*0.3), tube 0.3
                const rainbowColors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
                rainbowColors.forEach((color, i) => {
                    const radius = 5 - (i * 0.3);
                    const arcGeometry = new THREE.TorusGeometry(radius, 0.3, 8, 32, Math.PI);
                    const arcMaterial = new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.9
                    });
                    const arc = new THREE.Mesh(arcGeometry, arcMaterial);
                    group.add(arc);
                });
                
                // Disco ball group
                const discoBallGroup = new THREE.Group();
                const discoBallRadius = 2.5;
                const tileSize = 0.35;
                const tileDepth = 0.08;
                
                // Dark core sphere behind tiles
                const coreGeometry = new THREE.SphereGeometry(discoBallRadius - tileDepth, 16, 16);
                const coreMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                discoBallGroup.add(core);
                
                // Create 3D mirror tiles arranged in a sphere pattern
                for (let lat = -80; lat <= 80; lat += 15) {
                    const latRad = lat * Math.PI / 180;
                    const ringRadius = Math.cos(latRad) * discoBallRadius;
                    const y = Math.sin(latRad) * discoBallRadius;
                    const circumference = 2 * Math.PI * ringRadius;
                    const tilesInRing = Math.max(4, Math.floor(circumference / (tileSize + 0.05)));
                    
                    for (let i = 0; i < tilesInRing; i++) {
                        const lon = (i / tilesInRing) * Math.PI * 2;
                        const x = Math.cos(lon) * ringRadius;
                        const z = Math.sin(lon) * ringRadius;
                        
                        const tileGeometry = new THREE.BoxGeometry(tileSize, tileSize, tileDepth);
                        // Alternate tile colors for visual interest
                        const tileColor = rainbowColors[(lat + 80 + i) % rainbowColors.length];
                        const tileMaterial = new THREE.MeshBasicMaterial({ color: tileColor });
                        const tile = new THREE.Mesh(tileGeometry, tileMaterial);
                        
                        tile.position.set(x, y, z);
                        tile.lookAt(x * 2, y * 2, z * 2);
                        discoBallGroup.add(tile);
                    }
                }
                
                // Top and bottom cap tiles
                const capMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const topCap = new THREE.Mesh(new THREE.BoxGeometry(tileSize, tileSize, tileDepth), capMaterial);
                topCap.position.set(0, discoBallRadius, 0);
                topCap.rotation.x = -Math.PI / 2;
                discoBallGroup.add(topCap);
                
                const bottomCap = new THREE.Mesh(new THREE.BoxGeometry(tileSize, tileSize, tileDepth), capMaterial.clone());
                bottomCap.position.set(0, -discoBallRadius, 0);
                bottomCap.rotation.x = Math.PI / 2;
                discoBallGroup.add(bottomCap);
                
                // Hanging rod
                const rodLength = 3;
                const rodGeometry = new THREE.CylinderGeometry(0.08, 0.08, rodLength, 8);
                const rodMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
                const rod = new THREE.Mesh(rodGeometry, rodMaterial);
                rod.position.y = discoBallRadius + rodLength / 2;
                discoBallGroup.add(rod);
                
                // Hook at top of rod
                const hookGeometry = new THREE.TorusGeometry(0.15, 0.04, 8, 16);
                const hookMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
                const hook = new THREE.Mesh(hookGeometry, hookMaterial);
                hook.position.y = discoBallRadius + rodLength;
                hook.rotation.x = Math.PI / 2;
                discoBallGroup.add(hook);
                
                // Position disco ball hanging from center top of rainbow (y=5 is top)
                discoBallGroup.position.set(0, 5 - discoBallRadius - 3, 0);
                group.add(discoBallGroup);
                
                return group;
            },

            'tree': function() {
                const group = new THREE.Group();
                
                // Cylindrical trunk (darker brown)
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x6B4423 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1;
                group.add(trunk);
                
                // Spherical foliage (not cone)
                const foliageGeometry = new THREE.SphereGeometry(1.5, 8, 8);
                const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = 2.5;
                group.add(foliage);
                
                return group;
            },

            'cactus': function() {
                const group = new THREE.Group();
                const cactusMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2.5, 8);
                const body = new THREE.Mesh(bodyGeometry, cactusMaterial);
                body.position.y = 1.25;
                group.add(body);
                
                const armGeometry = new THREE.CylinderGeometry(0.15, 0.2, 1.0, 6);
                const arm1 = new THREE.Mesh(armGeometry, cactusMaterial);
                arm1.position.set(0.5, 1.5, 0);
                arm1.rotation.z = -Math.PI / 4;
                group.add(arm1);
                
                const arm2 = new THREE.Mesh(armGeometry, cactusMaterial);
                arm2.position.set(-0.4, 1.8, 0);
                arm2.rotation.z = Math.PI / 4;
                group.add(arm2);
                
                return group;
            },

            'palm': function() {
                const group = new THREE.Group();
                
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 3, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1.5;
                trunk.rotation.z = 0.1;
                group.add(trunk);
                
                const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22, side: THREE.DoubleSide });
                for (let i = 0; i < 6; i++) {
                    const leafGeometry = new THREE.PlaneGeometry(0.5, 2);
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    leaf.position.set(Math.cos(angle) * 0.3, 3.2, Math.sin(angle) * 0.3);
                    leaf.rotation.x = -0.5;
                    leaf.rotation.y = angle;
                    group.add(leaf);
                }
                
                return group;
            },

            'pyramid': function() {
                const group = new THREE.Group();
                const pyramidGeometry = new THREE.ConeGeometry(3, 4, 4);
                const pyramidMaterial = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
                const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
                pyramid.position.y = 2;
                pyramid.rotation.y = Math.PI / 4;
                group.add(pyramid);
                
                return group;
            },

            // CANDY LEVEL ENTITIES
            'gummy-bear': function() {
                const group = new THREE.Group();
                const gummyColor = 0xFF6B6B; // Red gummy
                const gummyMaterial = new THREE.MeshPhongMaterial({
                    color: gummyColor,
                    transparent: true,
                    opacity: 0.85,
                    shininess: 100
                });

                // Body - rounded belly
                const bodyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const body = new THREE.Mesh(bodyGeometry, gummyMaterial);
                body.scale.set(1, 1.2, 0.8);
                body.position.y = 0.8;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const head = new THREE.Mesh(headGeometry, gummyMaterial);
                head.position.y = 1.6;
                group.add(head);

                // Ears
                const earGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                const ear1 = new THREE.Mesh(earGeometry, gummyMaterial);
                ear1.position.set(-0.25, 1.95, 0);
                group.add(ear1);
                const ear2 = new THREE.Mesh(earGeometry, gummyMaterial);
                ear2.position.set(0.25, 1.95, 0);
                group.add(ear2);

                // Eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.15, 1.65, 0.35);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.15, 1.65, 0.35);
                group.add(eye2);

                // Arms
                const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const arm1 = new THREE.Mesh(armGeometry, gummyMaterial);
                arm1.scale.set(1, 1.5, 1);
                arm1.position.set(-0.55, 0.9, 0);
                group.add(arm1);
                const arm2 = new THREE.Mesh(armGeometry, gummyMaterial);
                arm2.scale.set(1, 1.5, 1);
                arm2.position.set(0.55, 0.9, 0);
                group.add(arm2);

                // Legs
                const legGeometry = new THREE.SphereGeometry(0.18, 8, 8);
                const leg1 = new THREE.Mesh(legGeometry, gummyMaterial);
                leg1.scale.set(1, 1.3, 1);
                leg1.position.set(-0.25, 0.2, 0);
                group.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, gummyMaterial);
                leg2.scale.set(1, 1.3, 1);
                leg2.position.set(0.25, 0.2, 0);
                group.add(leg2);

                return group;
            },

            'gingerbread-man': function() {
                const group = new THREE.Group();
                const cookieColor = 0xCD853F;
                const cookieMaterial = new THREE.MeshLambertMaterial({ color: cookieColor });
                const icingMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });

                // Body
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.6, 1.2, 8);
                const body = new THREE.Mesh(bodyGeometry, cookieMaterial);
                body.position.y = 1.0;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.45, 12, 12);
                const head = new THREE.Mesh(headGeometry, cookieMaterial);
                head.scale.set(1, 0.9, 0.7);
                head.position.y = 2.0;
                group.add(head);

                // Button eyes
                const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
                const buttonGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 8);
                const eye1 = new THREE.Mesh(buttonGeometry, buttonMaterial);
                eye1.rotation.x = Math.PI / 2;
                eye1.position.set(-0.15, 2.05, 0.35);
                group.add(eye1);
                const eye2 = new THREE.Mesh(buttonGeometry, buttonMaterial);
                eye2.rotation.x = Math.PI / 2;
                eye2.position.set(0.15, 2.05, 0.35);
                group.add(eye2);

                // Icing smile
                const smileGeometry = new THREE.TorusGeometry(0.15, 0.03, 8, 16, Math.PI);
                const smile = new THREE.Mesh(smileGeometry, icingMaterial);
                smile.position.set(0, 1.85, 0.38);
                smile.rotation.x = Math.PI;
                group.add(smile);

                // Body buttons
                for (let i = 0; i < 3; i++) {
                    const btn = new THREE.Mesh(buttonGeometry, buttonMaterial);
                    btn.rotation.x = Math.PI / 2;
                    btn.position.set(0, 1.3 - i * 0.25, 0.55);
                    group.add(btn);
                }

                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.8, 6);
                const arm1 = new THREE.Mesh(armGeometry, cookieMaterial);
                arm1.position.set(-0.6, 1.2, 0);
                arm1.rotation.z = Math.PI / 4;
                group.add(arm1);
                const arm2 = new THREE.Mesh(armGeometry, cookieMaterial);
                arm2.position.set(0.6, 1.2, 0);
                arm2.rotation.z = -Math.PI / 4;
                group.add(arm2);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.18, 0.7, 6);
                const leg1 = new THREE.Mesh(legGeometry, cookieMaterial);
                leg1.position.set(-0.25, 0.35, 0);
                group.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, cookieMaterial);
                leg2.position.set(0.25, 0.35, 0);
                group.add(leg2);

                return group;
            },

            'marshmallow-monster': function() {
                const group = new THREE.Group();
                const marshmallowMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFFAFA,
                    shininess: 30
                });
                const blushMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFB6C1,
                    transparent: true,
                    opacity: 0.6
                });

                // Large fluffy body
                const bodyGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const body = new THREE.Mesh(bodyGeometry, marshmallowMaterial);
                body.scale.set(1, 1.2, 1);
                body.position.y = 2.0;
                group.add(body);

                // Smaller head on top
                const headGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const head = new THREE.Mesh(headGeometry, marshmallowMaterial);
                head.position.y = 3.8;
                group.add(head);

                // Eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.3, 3.85, 0.65);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.3, 3.85, 0.65);
                group.add(eye2);

                // Blush circles
                const blushGeometry = new THREE.CircleGeometry(0.15, 12);
                const blush1 = new THREE.Mesh(blushGeometry, blushMaterial);
                blush1.position.set(-0.5, 3.7, 0.7);
                group.add(blush1);
                const blush2 = new THREE.Mesh(blushGeometry, blushMaterial);
                blush2.position.set(0.5, 3.7, 0.7);
                group.add(blush2);

                // Stubby arms
                const armGeometry = new THREE.SphereGeometry(0.4, 12, 12);
                const arm1 = new THREE.Mesh(armGeometry, marshmallowMaterial);
                arm1.scale.set(0.8, 1.2, 0.8);
                arm1.position.set(-1.6, 2.2, 0);
                group.add(arm1);
                const arm2 = new THREE.Mesh(armGeometry, marshmallowMaterial);
                arm2.scale.set(0.8, 1.2, 0.8);
                arm2.position.set(1.6, 2.2, 0);
                group.add(arm2);

                // Stubby legs
                const legGeometry = new THREE.SphereGeometry(0.5, 12, 12);
                const leg1 = new THREE.Mesh(legGeometry, marshmallowMaterial);
                leg1.scale.set(1, 0.8, 1);
                leg1.position.set(-0.7, 0.4, 0);
                group.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, marshmallowMaterial);
                leg2.scale.set(1, 0.8, 1);
                leg2.position.set(0.7, 0.4, 0);
                group.add(leg2);

                return group;
            },

            'cotton-candy-wizard': function() {
                const group = new THREE.Group();
                const pinkMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFF69B4,
                    transparent: true,
                    opacity: 0.9,
                    shininess: 50
                });
                const blueMaterial = new THREE.MeshPhongMaterial({
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.9,
                    shininess: 50
                });

                // Fluffy body (cylinder)
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.9, 2.2, 16);
                const body = new THREE.Mesh(bodyGeometry, pinkMaterial);
                body.position.y = 1.4;
                group.add(body);

                // Cotton candy fluff pieces
                for (let i = 0; i < 8; i++) {
                    const fluffGeometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.15, 12, 12);
                    const fluffMat = i % 2 === 0 ? pinkMaterial : blueMaterial;
                    const fluff = new THREE.Mesh(fluffGeometry, fluffMat);
                    const angle = (i / 8) * Math.PI * 2;
                    const height = 0.8 + Math.random() * 1.2;
                    fluff.position.set(Math.cos(angle) * 0.6, height, Math.sin(angle) * 0.6);
                    group.add(fluff);
                }

                // Head
                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const head = new THREE.Mesh(headGeometry, blueMaterial);
                head.position.y = 2.7;
                group.add(head);

                // Wizard hat (cone)
                const hatGeometry = new THREE.ConeGeometry(0.5, 1.2, 16);
                const hat = new THREE.Mesh(hatGeometry, pinkMaterial);
                hat.position.y = 3.6;
                group.add(hat);

                // Eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.2, 2.75, 0.4);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.2, 2.75, 0.4);
                group.add(eye2);

                // Lollipop wand
                const stickGeometry = new THREE.CylinderGeometry(0.04, 0.04, 2.0, 8);
                const stickMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const stick = new THREE.Mesh(stickGeometry, stickMaterial);
                stick.position.set(0.7, 1.5, 0.3);
                stick.rotation.z = -0.2;
                group.add(stick);

                const lolliGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                const lolliMaterial = new THREE.MeshPhongMaterial({ color: 0xFF00FF, shininess: 80 });
                const lolli = new THREE.Mesh(lolliGeometry, lolliMaterial);
                lolli.position.set(0.8, 2.6, 0.3);
                group.add(lolli);

                return group;
            },

            // GRAVEYARD LEVEL ENTITIES
            'zombie': function() {
                const group = new THREE.Group();
                const zombieGreen = 0x4a6a4a;
                const rottenFlesh = 0x3a5a3a;
                const boneWhite = 0xd0c8b0;

                // Body - torn clothes
                const bodyGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3a3a2a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.0;
                group.add(body);

                // Head - partially decayed
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: zombieGreen });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.scale.set(1, 0.9, 0.9);
                head.position.y = 1.8;
                group.add(head);

                // Exposed skull patch
                const skullGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const skullMaterial = new THREE.MeshLambertMaterial({ color: boneWhite });
                const skull = new THREE.Mesh(skullGeometry, skullMaterial);
                skull.position.set(0.2, 1.95, 0.2);
                group.add(skull);

                // Glowing eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00FF00 });
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.12, 1.85, 0.35);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.12, 1.85, 0.35);
                group.add(eye2);

                // Arms - one skeletal
                const armGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.8, 6);
                const arm1 = new THREE.Mesh(armGeometry, new THREE.MeshLambertMaterial({ color: rottenFlesh }));
                arm1.position.set(-0.45, 1.1, 0);
                arm1.rotation.z = 0.4;
                arm1.rotation.x = -0.3;
                group.add(arm1);

                const arm2 = new THREE.Mesh(armGeometry, new THREE.MeshLambertMaterial({ color: boneWhite }));
                arm2.position.set(0.45, 1.1, 0);
                arm2.rotation.z = -0.5;
                arm2.rotation.x = -0.2;
                group.add(arm2);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.9, 6);
                const leg1 = new THREE.Mesh(legGeometry, bodyMaterial);
                leg1.position.set(-0.18, 0.45, 0);
                group.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, bodyMaterial);
                leg2.position.set(0.18, 0.45, 0);
                leg2.rotation.z = 0.1;
                group.add(leg2);

                return group;
            },

            'ghost': function() {
                const group = new THREE.Group();
                const ghostMaterial = new THREE.MeshPhongMaterial({
                    color: 0xaabbcc,
                    transparent: true,
                    opacity: 0.6,
                    shininess: 30
                });

                // Ethereal body - flowing shape
                const bodyGeometry = new THREE.ConeGeometry(0.8, 2.5, 12);
                const body = new THREE.Mesh(bodyGeometry, ghostMaterial);
                body.position.y = 1.5;
                body.rotation.x = Math.PI;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const head = new THREE.Mesh(headGeometry, ghostMaterial);
                head.position.y = 2.9;
                group.add(head);

                // Glowing eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00FFFF,
                    transparent: true
                });
                const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.18, 2.95, 0.4);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.18, 2.95, 0.4);
                group.add(eye2);

                // Wispy arms
                const armGeometry = new THREE.CylinderGeometry(0.05, 0.15, 1.2, 6);
                const arm1 = new THREE.Mesh(armGeometry, ghostMaterial);
                arm1.position.set(-0.6, 2.2, 0.2);
                arm1.rotation.z = 0.5;
                arm1.rotation.x = -0.3;
                group.add(arm1);
                const arm2 = new THREE.Mesh(armGeometry, ghostMaterial);
                arm2.position.set(0.6, 2.2, 0.2);
                arm2.rotation.z = -0.5;
                arm2.rotation.x = -0.3;
                group.add(arm2);

                // Ethereal glow particles
                for (let i = 0; i < 6; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.08, 6, 6);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88FFFF,
                        transparent: true,
                        opacity: 0.4
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    particle.position.set(
                        Math.cos(angle) * 0.7,
                        1.5 + i * 0.3,
                        Math.sin(angle) * 0.7
                    );
                    group.add(particle);
                }

                return group;
            },

            'skeleton': function() {
                const group = new THREE.Group();
                const boneWhite = 0xe8e0d0;
                const boneShadow = 0xc0b8a8;
                const eyeGlow = 0xFF4444;

                // Skull
                const skullGeometry = new THREE.SphereGeometry(0.4, 12, 12);
                const skullMaterial = new THREE.MeshLambertMaterial({ color: boneWhite });
                const skull = new THREE.Mesh(skullGeometry, skullMaterial);
                skull.scale.set(1, 1.1, 0.9);
                skull.position.y = 1.8;
                group.add(skull);

                // Eye sockets (dark hollows)
                const socketGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const socketMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1010 });
                const socket1 = new THREE.Mesh(socketGeometry, socketMaterial);
                socket1.position.set(-0.12, 1.85, 0.32);
                group.add(socket1);
                const socket2 = new THREE.Mesh(socketGeometry, socketMaterial);
                socket2.position.set(0.12, 1.85, 0.32);
                group.add(socket2);

                // Glowing red eyes
                const eyeGlowGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                const eyeGlowMaterial = new THREE.MeshBasicMaterial({ 
                    color: eyeGlow,
                    transparent: true,
                    opacity: 0.9
                });
                const glow1 = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
                glow1.position.set(-0.12, 1.85, 0.35);
                group.add(glow1);
                const glow2 = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
                glow2.position.set(0.12, 1.85, 0.35);
                group.add(glow2);

                // Nose hole
                const noseGeometry = new THREE.ConeGeometry(0.06, 0.1, 3);
                const noseMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1010 });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(0, 1.75, 0.35);
                nose.rotation.x = Math.PI;
                group.add(nose);

                // Jaw with teeth
                const jawGeometry = new THREE.BoxGeometry(0.3, 0.12, 0.15);
                const jawMaterial = new THREE.MeshLambertMaterial({ color: boneShadow });
                const jaw = new THREE.Mesh(jawGeometry, jawMaterial);
                jaw.position.set(0, 1.58, 0.28);
                group.add(jaw);

                // Teeth
                for (let i = 0; i < 5; i++) {
                    const toothGeometry = new THREE.BoxGeometry(0.04, 0.08, 0.04);
                    const toothMaterial = new THREE.MeshLambertMaterial({ color: boneWhite });
                    const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                    tooth.position.set(-0.1 + i * 0.05, 1.62, 0.35);
                    group.add(tooth);
                }

                // Spine
                const spineGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.9, 6);
                const spineMaterial = new THREE.MeshLambertMaterial({ color: boneShadow });
                const spine = new THREE.Mesh(spineGeometry, spineMaterial);
                spine.position.y = 1.1;
                group.add(spine);

                // Ribs
                for (let i = 0; i < 4; i++) {
                    const ribGeometry = new THREE.TorusGeometry(0.25, 0.03, 6, 12, Math.PI);
                    const ribMaterial = new THREE.MeshLambertMaterial({ color: boneWhite });
                    const rib = new THREE.Mesh(ribGeometry, ribMaterial);
                    rib.position.set(0, 1.35 - i * 0.15, 0.1);
                    rib.rotation.x = -Math.PI / 2;
                    rib.rotation.z = Math.PI;
                    group.add(rib);
                }

                // Pelvis
                const pelvisGeometry = new THREE.BoxGeometry(0.4, 0.15, 0.2);
                const pelvisMaterial = new THREE.MeshLambertMaterial({ color: boneShadow });
                const pelvis = new THREE.Mesh(pelvisGeometry, pelvisMaterial);
                pelvis.position.y = 0.6;
                group.add(pelvis);

                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.04, 0.05, 0.6, 6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: boneWhite });
                const upperArm1 = new THREE.Mesh(armGeometry, armMaterial);
                upperArm1.position.set(-0.35, 1.2, 0);
                upperArm1.rotation.z = 0.3;
                group.add(upperArm1);
                const upperArm2 = new THREE.Mesh(armGeometry, armMaterial);
                upperArm2.position.set(0.35, 1.2, 0);
                upperArm2.rotation.z = -0.3;
                group.add(upperArm2);

                const forearm1 = new THREE.Mesh(armGeometry, armMaterial);
                forearm1.position.set(-0.55, 0.75, 0.1);
                forearm1.rotation.z = 0.8;
                forearm1.rotation.x = -0.3;
                group.add(forearm1);
                const forearm2 = new THREE.Mesh(armGeometry, armMaterial);
                forearm2.position.set(0.55, 0.75, 0.1);
                forearm2.rotation.z = -0.8;
                forearm2.rotation.x = -0.3;
                group.add(forearm2);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.05, 0.06, 0.5, 6);
                const leg1 = new THREE.Mesh(legGeometry, armMaterial);
                leg1.position.set(-0.12, 0.3, 0);
                group.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, armMaterial);
                leg2.position.set(0.12, 0.3, 0);
                group.add(leg2);

                // Bone bow
                const bowGroup = new THREE.Group();
                const bowCurve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(0, -0.5, 0),
                    new THREE.Vector3(0.3, 0, 0),
                    new THREE.Vector3(0, 0.5, 0)
                );
                const bowTubeGeometry = new THREE.TubeGeometry(bowCurve, 20, 0.04, 8, false);
                const bowMaterial = new THREE.MeshLambertMaterial({ color: boneWhite });
                const bowLimb = new THREE.Mesh(bowTubeGeometry, bowMaterial);
                bowGroup.add(bowLimb);
                
                const stringGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1.0, 4);
                const stringMaterial = new THREE.MeshBasicMaterial({ color: 0x3a3a3a });
                const bowString = new THREE.Mesh(stringGeometry, stringMaterial);
                bowGroup.add(bowString);
                
                bowGroup.position.set(-0.65, 1.0, 0.2);
                bowGroup.rotation.z = 0.3;
                group.add(bowGroup);
                
                // Quiver with arrows
                const quiverGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.6, 8);
                const quiverMaterial = new THREE.MeshLambertMaterial({ color: boneShadow });
                const quiver = new THREE.Mesh(quiverGeometry, quiverMaterial);
                quiver.position.set(0, 1.2, -0.25);
                quiver.rotation.x = 0.2;
                group.add(quiver);
                
                for (let i = 0; i < 3; i++) {
                    const arrowShaftGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);
                    const arrowShaftMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
                    const arrowShaft = new THREE.Mesh(arrowShaftGeometry, arrowShaftMaterial);
                    arrowShaft.position.set(-0.05 + i * 0.05, 1.5, -0.25);
                    arrowShaft.rotation.x = 0.15;
                    group.add(arrowShaft);
                }

                return group;
            },

            'witch': function() {
                const group = new THREE.Group();
                const greenSkin = 0x4a8a4a;
                const blackRobe = 0x1a1a2a;
                const purpleAccent = 0x6a2a8a;

                // Robe body
                const robeGeometry = new THREE.CylinderGeometry(0.3, 0.8, 2.0, 12);
                const robeMaterial = new THREE.MeshLambertMaterial({ color: blackRobe });
                const robe = new THREE.Mesh(robeGeometry, robeMaterial);
                robe.position.y = 1.2;
                group.add(robe);

                // Head - green skin
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: greenSkin });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.5;
                group.add(head);

                // Big nose with wart
                const noseGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
                const nose = new THREE.Mesh(noseGeometry, headMaterial);
                nose.position.set(0, 2.45, 0.4);
                nose.rotation.x = -0.3;
                group.add(nose);

                const wartGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                const wartMaterial = new THREE.MeshLambertMaterial({ color: 0x2a5a2a });
                const wart = new THREE.Mesh(wartGeometry, wartMaterial);
                wart.position.set(0.05, 2.5, 0.5);
                group.add(wart);

                // Pointy witch hat
                const hatBrimGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.1, 16);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: purpleAccent });
                const brim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
                brim.position.y = 2.9;
                group.add(brim);

                const hatConeGeometry = new THREE.ConeGeometry(0.4, 1.2, 12);
                const hatCone = new THREE.Mesh(hatConeGeometry, hatMaterial);
                hatCone.position.y = 3.5;
                hatCone.rotation.z = 0.15;
                group.add(hatCone);

                // Glowing eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF00FF });
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.15, 2.55, 0.32);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.15, 2.55, 0.32);
                group.add(eye2);

                // Broomstick
                const broomHandleGeometry = new THREE.CylinderGeometry(0.04, 0.04, 2.5, 6);
                const broomMaterial = new THREE.MeshLambertMaterial({ color: 0x5a4020 });
                const broomHandle = new THREE.Mesh(broomHandleGeometry, broomMaterial);
                broomHandle.position.set(0.6, 1.0, 0);
                broomHandle.rotation.z = -0.2;
                group.add(broomHandle);

                const bristlesGeometry = new THREE.ConeGeometry(0.15, 0.5, 8);
                const bristlesMaterial = new THREE.MeshLambertMaterial({ color: 0x8a6a30 });
                const bristles = new THREE.Mesh(bristlesGeometry, bristlesMaterial);
                bristles.position.set(0.45, -0.15, 0);
                bristles.rotation.x = Math.PI;
                group.add(bristles);

                return group;
            },

            'executioner': function() {
                const group = new THREE.Group();
                const hoodBlack = 0x1a1a1a;
                const axeGray = 0x4a4a4a;
                const bloodRed = 0x8a0000;

                // Massive body
                const bodyGeometry = new THREE.BoxGeometry(1.4, 2.2, 0.9);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: hoodBlack });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.6;
                group.add(body);

                // Hood/head
                const hoodGeometry = new THREE.ConeGeometry(0.6, 1.0, 12);
                const hood = new THREE.Mesh(hoodGeometry, bodyMaterial);
                hood.position.y = 3.2;
                hood.rotation.x = 0.1;
                group.add(hood);

                // Dark eye holes
                const eyeHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eyeHoleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeHole1 = new THREE.Mesh(eyeHoleGeometry, eyeHoleMaterial);
                eyeHole1.position.set(-0.2, 2.9, 0.4);
                group.add(eyeHole1);
                const eyeHole2 = new THREE.Mesh(eyeHoleGeometry, eyeHoleMaterial);
                eyeHole2.position.set(0.2, 2.9, 0.4);
                group.add(eyeHole2);

                // Massive arms
                const armGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1.3, 8);
                const arm1 = new THREE.Mesh(armGeometry, bodyMaterial);
                arm1.position.set(-0.9, 1.8, 0);
                arm1.rotation.z = 0.2;
                group.add(arm1);
                const arm2 = new THREE.Mesh(armGeometry, bodyMaterial);
                arm2.position.set(0.9, 1.8, 0);
                arm2.rotation.z = -0.3;
                group.add(arm2);

                // Giant axe
                const axeHandleGeometry = new THREE.CylinderGeometry(0.08, 0.08, 3.0, 8);
                const axeHandleMaterial = new THREE.MeshLambertMaterial({ color: 0x3a2010 });
                const axeHandle = new THREE.Mesh(axeHandleGeometry, axeHandleMaterial);
                axeHandle.position.set(1.1, 2.2, 0.3);
                axeHandle.rotation.z = -0.4;
                group.add(axeHandle);

                // Axe blade
                const bladeShape = new THREE.Shape();
                bladeShape.moveTo(0, 0);
                bladeShape.lineTo(0.8, 0.2);
                bladeShape.quadraticCurveTo(1.2, 0, 0.8, -0.2);
                bladeShape.lineTo(0, 0);

                const bladeGeometry = new THREE.ExtrudeGeometry(bladeShape, { depth: 0.08, bevelEnabled: false });
                const bladeMaterial = new THREE.MeshPhongMaterial({ color: axeGray, shininess: 80 });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.set(1.3, 3.4, 0.25);
                blade.rotation.z = -0.4;
                group.add(blade);

                // Blood stains on blade
                const bloodGeometry = new THREE.SphereGeometry(0.08, 6, 6);
                const bloodMaterial = new THREE.MeshBasicMaterial({ color: bloodRed });
                for (let i = 0; i < 4; i++) {
                    const blood = new THREE.Mesh(bloodGeometry, bloodMaterial);
                    blood.position.set(1.5 + i * 0.15, 3.3 + Math.random() * 0.2, 0.35);
                    group.add(blood);
                }

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1.0, 8);
                const leg1 = new THREE.Mesh(legGeometry, bodyMaterial);
                leg1.position.set(-0.35, 0.5, 0);
                group.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, bodyMaterial);
                leg2.position.set(0.35, 0.5, 0);
                group.add(leg2);

                return group;
            },

            'bat': function() {
                const group = new THREE.Group();
                const batBlack = 0x1a1a2a;
                const wingMembrane = 0x2a2a3a;

                // Body
                const bodyGeometry = new THREE.SphereGeometry(0.3, 12, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: batBlack });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.scale.set(1, 1.2, 0.8);
                body.position.y = 1.5;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.set(0, 1.8, 0.15);
                group.add(head);

                // Ears
                const earGeometry = new THREE.ConeGeometry(0.08, 0.25, 4);
                const ear1 = new THREE.Mesh(earGeometry, bodyMaterial);
                ear1.position.set(-0.12, 2.0, 0.1);
                ear1.rotation.z = -0.2;
                group.add(ear1);
                const ear2 = new THREE.Mesh(earGeometry, bodyMaterial);
                ear2.position.set(0.12, 2.0, 0.1);
                ear2.rotation.z = 0.2;
                group.add(ear2);

                // Glowing red eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.08, 1.82, 0.32);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.08, 1.82, 0.32);
                group.add(eye2);

                // Wings - membrane style
                const wingMaterial = new THREE.MeshLambertMaterial({ 
                    color: wingMembrane,
                    side: THREE.DoubleSide
                });

                // Left wing
                const leftWingShape = new THREE.Shape();
                leftWingShape.moveTo(0, 0);
                leftWingShape.lineTo(-0.8, 0.3);
                leftWingShape.lineTo(-1.2, 0);
                leftWingShape.lineTo(-0.9, -0.2);
                leftWingShape.lineTo(-0.5, -0.1);
                leftWingShape.lineTo(0, 0);
                
                const leftWingGeometry = new THREE.ShapeGeometry(leftWingShape);
                const leftWing = new THREE.Mesh(leftWingGeometry, wingMaterial);
                leftWing.position.set(-0.2, 1.5, 0);
                leftWing.rotation.y = 0.3;
                group.add(leftWing);

                // Right wing
                const rightWingShape = new THREE.Shape();
                rightWingShape.moveTo(0, 0);
                rightWingShape.lineTo(0.8, 0.3);
                rightWingShape.lineTo(1.2, 0);
                rightWingShape.lineTo(0.9, -0.2);
                rightWingShape.lineTo(0.5, -0.1);
                rightWingShape.lineTo(0, 0);
                
                const rightWingGeometry = new THREE.ShapeGeometry(rightWingShape);
                const rightWing = new THREE.Mesh(rightWingGeometry, wingMaterial);
                rightWing.position.set(0.2, 1.5, 0);
                rightWing.rotation.y = -0.3;
                group.add(rightWing);

                return group;
            },

            'reaper': function() {
                const group = new THREE.Group();
                const cloakBlack = 0x050508;
                const boneWhite = 0xd0c8b0;
                const glowGreen = 0x00FF44;

                // Main robe
                const robeGeometry = new THREE.CylinderGeometry(0.8, 1.4, 3.5, 16);
                const robeMaterial = new THREE.MeshLambertMaterial({ color: cloakBlack });
                const robe = new THREE.Mesh(robeGeometry, robeMaterial);
                robe.position.y = 2.0;
                group.add(robe);

                // Tattered edges
                for (let i = 0; i < 12; i++) {
                    const tatGeometry = new THREE.ConeGeometry(0.15, 0.8, 4);
                    const tat = new THREE.Mesh(tatGeometry, robeMaterial);
                    const angle = (i / 12) * Math.PI * 2;
                    tat.position.set(Math.cos(angle) * 1.3, 0.4, Math.sin(angle) * 1.3);
                    tat.rotation.x = Math.PI;
                    group.add(tat);
                }

                // Hood
                const hoodGeometry = new THREE.ConeGeometry(0.7, 1.2, 12);
                const hood = new THREE.Mesh(hoodGeometry, robeMaterial);
                hood.position.y = 4.5;
                hood.rotation.x = 0.15;
                group.add(hood);

                // Dark void face
                const voidGeometry = new THREE.SphereGeometry(0.4, 12, 12);
                const voidMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const faceVoid = new THREE.Mesh(voidGeometry, voidMaterial);
                faceVoid.position.set(0, 4.1, 0.35);
                faceVoid.scale.z = 0.5;
                group.add(faceVoid);

                // Glowing red eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.15, 4.15, 0.55);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.15, 4.15, 0.55);
                group.add(eye2);

                // Skeletal hands
                const handMaterial = new THREE.MeshLambertMaterial({ color: boneWhite });
                const handGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.1);
                const leftHand = new THREE.Mesh(handGeometry, handMaterial);
                leftHand.position.set(-1.0, 3.0, 0.5);
                group.add(leftHand);
                const rightHand = new THREE.Mesh(handGeometry, handMaterial);
                rightHand.position.set(1.0, 3.0, 0.5);
                group.add(rightHand);

                // Giant scythe
                const handleGeometry = new THREE.CylinderGeometry(0.06, 0.06, 4.5, 8);
                const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x2a1a0a });
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.position.set(-1.2, 3.5, 0.6);
                handle.rotation.z = 0.25;
                group.add(handle);

                // Scythe blade
                const bladeShape = new THREE.Shape();
                bladeShape.moveTo(0, 0);
                bladeShape.lineTo(1.5, 0.3);
                bladeShape.quadraticCurveTo(2.2, 0.1, 2.4, -0.3);
                bladeShape.quadraticCurveTo(1.8, -0.1, 1.2, 0);
                bladeShape.lineTo(0, 0);

                const bladeGeometry = new THREE.ExtrudeGeometry(bladeShape, { depth: 0.03, bevelEnabled: false });
                const bladeMaterial = new THREE.MeshPhongMaterial({ color: 0x3a3a3a, shininess: 100 });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.set(-1.5, 5.5, 0.55);
                blade.rotation.z = 0.4;
                group.add(blade);

                // Ghostly particles
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: glowGreen,
                    transparent: true,
                    opacity: 0.4
                });
                for (let i = 0; i < 6; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.1, 6, 6);
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.set(
                        (Math.random() - 0.5) * 1.5,
                        1 + Math.random() * 3,
                        (Math.random() - 0.5) * 1.5
                    );
                    group.add(particle);
                }

                return group;
            },

            'tombstone': function() {
                const group = new THREE.Group();
                const stoneGray = 0x5a5a5a;

                // Main stone slab
                const stoneGeometry = new THREE.BoxGeometry(1.2, 2.0, 0.3);
                const stoneMaterial = new THREE.MeshLambertMaterial({ color: stoneGray });
                const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                stone.position.y = 1.0;
                group.add(stone);

                // Rounded top
                const topGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.3, 16, 1, false, 0, Math.PI);
                const top = new THREE.Mesh(topGeometry, stoneMaterial);
                top.position.set(0, 2.0, 0);
                top.rotation.z = Math.PI / 2;
                top.rotation.y = Math.PI / 2;
                group.add(top);

                // Weathered texture (darker patches)
                const patchMaterial = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
                for (let i = 0; i < 5; i++) {
                    const patchGeometry = new THREE.BoxGeometry(0.2 + Math.random() * 0.3, 0.1 + Math.random() * 0.2, 0.05);
                    const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                    patch.position.set(
                        (Math.random() - 0.5) * 0.8,
                        0.5 + Math.random() * 1.2,
                        0.18
                    );
                    group.add(patch);
                }

                // Cross carving
                const crossVertGeometry = new THREE.BoxGeometry(0.08, 0.5, 0.05);
                const crossMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
                const crossVert = new THREE.Mesh(crossVertGeometry, crossMaterial);
                crossVert.position.set(0, 1.5, 0.18);
                group.add(crossVert);

                const crossHorizGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.05);
                const crossHoriz = new THREE.Mesh(crossHorizGeometry, crossMaterial);
                crossHoriz.position.set(0, 1.6, 0.18);
                group.add(crossHoriz);

                return group;
            },

            'dead-tree': function() {
                const group = new THREE.Group();
                const barkColor = 0x2a2015;
                const barkMaterial = new THREE.MeshLambertMaterial({ color: barkColor });

                // Main trunk - twisted
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.4, 3.5, 8);
                const trunk = new THREE.Mesh(trunkGeometry, barkMaterial);
                trunk.position.y = 1.75;
                trunk.rotation.z = 0.1;
                group.add(trunk);

                // Bare branches
                const branchGeometry = new THREE.CylinderGeometry(0.03, 0.1, 1.5, 6);
                
                const branch1 = new THREE.Mesh(branchGeometry, barkMaterial);
                branch1.position.set(-0.4, 3.0, 0);
                branch1.rotation.z = 0.8;
                group.add(branch1);

                const branch2 = new THREE.Mesh(branchGeometry, barkMaterial);
                branch2.position.set(0.5, 2.8, 0.1);
                branch2.rotation.z = -0.6;
                group.add(branch2);

                const branch3 = new THREE.Mesh(branchGeometry, barkMaterial);
                branch3.position.set(0.1, 3.3, -0.3);
                branch3.rotation.z = -0.2;
                branch3.rotation.x = 0.5;
                group.add(branch3);

                const branch4 = new THREE.Mesh(branchGeometry, barkMaterial);
                branch4.position.set(-0.3, 2.5, 0.2);
                branch4.rotation.z = 1.0;
                branch4.rotation.y = 0.3;
                group.add(branch4);

                // Smaller twigs
                const twigGeometry = new THREE.CylinderGeometry(0.01, 0.03, 0.6, 4);
                for (let i = 0; i < 8; i++) {
                    const twig = new THREE.Mesh(twigGeometry, barkMaterial);
                    const baseX = (Math.random() - 0.5) * 1.2;
                    const baseY = 2.5 + Math.random() * 1.2;
                    twig.position.set(baseX, baseY, (Math.random() - 0.5) * 0.5);
                    twig.rotation.set(Math.random() * 0.5, Math.random(), Math.random() - 0.5);
                    group.add(twig);
                }

                return group;
            },

            'grave-mound': function() {
                const group = new THREE.Group();
                const dirtColor = 0x3a3020;

                // Mound shape
                const moundGeometry = new THREE.SphereGeometry(1.2, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                const moundMaterial = new THREE.MeshLambertMaterial({ color: dirtColor });
                const mound = new THREE.Mesh(moundGeometry, moundMaterial);
                mound.scale.set(1, 0.4, 0.7);
                mound.position.y = 0;
                group.add(mound);

                // Dirt clumps
                const clumpMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2015 });
                for (let i = 0; i < 6; i++) {
                    const clumpGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 6, 6);
                    const clump = new THREE.Mesh(clumpGeometry, clumpMaterial);
                    clump.position.set(
                        (Math.random() - 0.5) * 1.5,
                        0.1 + Math.random() * 0.2,
                        (Math.random() - 0.5) * 0.8
                    );
                    group.add(clump);
                }

                // Simple wooden cross
                const woodMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
                const vertGeometry = new THREE.BoxGeometry(0.08, 0.8, 0.05);
                const vert = new THREE.Mesh(vertGeometry, woodMaterial);
                vert.position.set(0, 0.6, -0.4);
                group.add(vert);

                const horizGeometry = new THREE.BoxGeometry(0.4, 0.06, 0.05);
                const horiz = new THREE.Mesh(horizGeometry, woodMaterial);
                horiz.position.set(0, 0.8, -0.4);
                group.add(horiz);

                return group;
            },

            'mist-pool': function() {
                const group = new THREE.Group();

                // Dark water surface
                const poolGeometry = new THREE.CircleGeometry(1.5, 24);
                const poolMaterial = new THREE.MeshPhongMaterial({
                    color: 0x1a2a3a,
                    shininess: 60,
                    transparent: true,
                    opacity: 0.8
                });
                const pool = new THREE.Mesh(poolGeometry, poolMaterial);
                pool.rotation.x = -Math.PI / 2;
                pool.position.y = 0.05;
                group.add(pool);

                // Mist rising
                const mistMaterial = new THREE.MeshBasicMaterial({
                    color: 0x8888aa,
                    transparent: true,
                    opacity: 0.3
                });
                for (let i = 0; i < 8; i++) {
                    const mistGeometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.3, 8, 8);
                    const mist = new THREE.Mesh(mistGeometry, mistMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    mist.position.set(
                        Math.cos(angle) * (0.5 + Math.random() * 0.7),
                        0.3 + Math.random() * 0.5,
                        Math.sin(angle) * (0.5 + Math.random() * 0.7)
                    );
                    mist.scale.set(1, 1.5, 1);
                    group.add(mist);
                }

                // Pool edge
                const edgeGeometry = new THREE.TorusGeometry(1.5, 0.1, 8, 24);
                const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
                edge.rotation.x = Math.PI / 2;
                edge.position.y = 0.05;
                group.add(edge);

                return group;
            },

            'lollipop': function() {
                const group = new THREE.Group();

                // White stick
                const stickGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3.5, 8);
                const stickMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const stick = new THREE.Mesh(stickGeometry, stickMaterial);
                stick.position.y = 1.75;
                group.add(stick);

                // Colorful candy top
                const candyGeometry = new THREE.SphereGeometry(1.2, 16, 16);
                const candyMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFF69B4,
                    shininess: 80
                });
                const candy = new THREE.Mesh(candyGeometry, candyMaterial);
                candy.position.y = 4.0;
                group.add(candy);

                // Swirl pattern
                const swirlGeometry = new THREE.TorusGeometry(0.8, 0.12, 8, 32, Math.PI * 3);
                const swirlMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, shininess: 80 });
                const swirl = new THREE.Mesh(swirlGeometry, swirlMaterial);
                swirl.position.y = 4.0;
                swirl.rotation.x = Math.PI / 2;
                group.add(swirl);

                return group;
            },

            'candy-cane': function() {
                const group = new THREE.Group();
                const whiteMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, shininess: 60 });
                const redMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000, shininess: 60 });

                // Main body
                const caneRadius = 0.2;
                const caneHeight = 4;
                const caneGeometry = new THREE.CylinderGeometry(caneRadius, caneRadius, caneHeight, 12);
                const cane = new THREE.Mesh(caneGeometry, whiteMaterial);
                cane.position.y = caneHeight / 2;
                group.add(cane);

                // Red stripes
                for (let i = 0; i < 8; i++) {
                    const stripeGeometry = new THREE.TorusGeometry(caneRadius + 0.02, 0.06, 8, 16);
                    const stripe = new THREE.Mesh(stripeGeometry, redMaterial);
                    stripe.position.y = 0.3 + i * 0.5;
                    stripe.rotation.x = Math.PI / 2;
                    group.add(stripe);
                }

                // Curved hook
                const hookGeometry = new THREE.TorusGeometry(0.5, caneRadius, 12, 16, Math.PI);
                const hook = new THREE.Mesh(hookGeometry, whiteMaterial);
                hook.position.set(0.5, caneHeight, 0);
                hook.rotation.z = Math.PI / 2;
                group.add(hook);

                return group;
            },

            'chocolate-river': function() {
                const group = new THREE.Group();

                // Chocolate river surface
                const riverGeometry = new THREE.PlaneGeometry(6, 3);
                const riverMaterial = new THREE.MeshPhongMaterial({
                    color: 0x5C4033,
                    shininess: 60
                });
                const river = new THREE.Mesh(riverGeometry, riverMaterial);
                river.rotation.x = -Math.PI / 2;
                river.position.y = 0.1;
                group.add(river);

                // Chocolate waves/ripples
                for (let i = 0; i < 5; i++) {
                    const waveGeometry = new THREE.TorusGeometry(0.3 + i * 0.15, 0.05, 8, 32);
                    const waveMaterial = new THREE.MeshPhongMaterial({
                        color: 0x7B5544,
                        shininess: 80
                    });
                    const wave = new THREE.Mesh(waveGeometry, waveMaterial);
                    wave.rotation.x = Math.PI / 2;
                    wave.position.set(-1.5 + i * 0.8, 0.15, 0);
                    group.add(wave);
                }

                // Chocolate drops splashing
                const dropMaterial = new THREE.MeshPhongMaterial({ color: 0x5C4033, shininess: 100 });
                for (let i = 0; i < 3; i++) {
                    const dropGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    const drop = new THREE.Mesh(dropGeometry, dropMaterial);
                    drop.position.set(-1 + i * 1.5, 0.4 + Math.random() * 0.3, 0.5 - Math.random());
                    group.add(drop);
                }

                return group;
            },

            'cupcake-hill': function() {
                const group = new THREE.Group();

                // Cupcake wrapper/base
                const wrapperGeometry = new THREE.CylinderGeometry(1.5, 1.2, 1.2, 16);
                const wrapperMaterial = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
                const wrapper = new THREE.Mesh(wrapperGeometry, wrapperMaterial);
                wrapper.position.y = 0.6;
                group.add(wrapper);

                // Wrapper ridges
                for (let i = 0; i < 12; i++) {
                    const ridgeGeometry = new THREE.BoxGeometry(0.08, 1.2, 0.3);
                    const ridge = new THREE.Mesh(ridgeGeometry, wrapperMaterial);
                    const angle = (i / 12) * Math.PI * 2;
                    ridge.position.set(Math.cos(angle) * 1.4, 0.6, Math.sin(angle) * 1.4);
                    ridge.rotation.y = angle;
                    group.add(ridge);
                }

                // Frosting top
                const frostingGeometry = new THREE.SphereGeometry(1.4, 16, 16);
                const frostingMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFFFFF,
                    shininess: 50
                });
                const frosting = new THREE.Mesh(frostingGeometry, frostingMaterial);
                frosting.scale.set(1, 0.6, 1);
                frosting.position.y = 1.8;
                group.add(frosting);

                // Swirl on top
                const swirlGeometry = new THREE.ConeGeometry(0.4, 0.8, 8);
                const swirlMaterial = new THREE.MeshPhongMaterial({ color: 0xFFB6C1 });
                const swirl = new THREE.Mesh(swirlGeometry, swirlMaterial);
                swirl.position.y = 2.5;
                group.add(swirl);

                // Cherry on top
                const cherryGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                const cherryMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000, shininess: 100 });
                const cherry = new THREE.Mesh(cherryGeometry, cherryMaterial);
                cherry.position.y = 3.1;
                group.add(cherry);

                // Sprinkles
                const sprinkleColors = [0xFF6347, 0xFFD700, 0x98FB98, 0x87CEEB, 0xDDA0DD];
                for (let i = 0; i < 15; i++) {
                    const sprinkleGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.2, 6);
                    const sprinkleMaterial = new THREE.MeshBasicMaterial({
                        color: sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)]
                    });
                    const sprinkle = new THREE.Mesh(sprinkleGeometry, sprinkleMaterial);
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 0.3 + Math.random() * 0.8;
                    sprinkle.position.set(
                        Math.cos(angle) * dist,
                        1.9 + Math.random() * 0.3,
                        Math.sin(angle) * dist
                    );
                    sprinkle.rotation.set(Math.random(), Math.random(), Math.random());
                    group.add(sprinkle);
                }

                return group;
            },

            // ========== RUINS LEVEL MOBS ==========

            'knight': function() {
                const group = new THREE.Group();
                const armorColor = 0x6a6a7a;
                const chainmailColor = 0x4a4a5a;
                const plumageColor = 0x8B0000;

                // Armored torso
                const bodyGeometry = new THREE.BoxGeometry(0.65, 0.85, 0.45);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: armorColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.85;
                group.add(body);

                // Chest plate detail
                const chestPlateGeometry = new THREE.BoxGeometry(0.5, 0.6, 0.1);
                const chestPlateMaterial = new THREE.MeshLambertMaterial({ color: 0x5a5a6a });
                const chestPlate = new THREE.Mesh(chestPlateGeometry, chestPlateMaterial);
                chestPlate.position.set(0, 0.9, 0.25);
                group.add(chestPlate);

                // Knight helmet
                const helmetGeometry = new THREE.SphereGeometry(0.38, 16, 16);
                const helmetMaterial = new THREE.MeshLambertMaterial({ color: armorColor });
                const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
                helmet.position.y = 1.55;
                group.add(helmet);

                // Helmet visor
                const visorGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.15);
                const visorMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a2a });
                const visor = new THREE.Mesh(visorGeometry, visorMaterial);
                visor.position.set(0, 1.5, 0.32);
                group.add(visor);

                // Eye slits (glowing blue)
                const eyeSlitGeometry = new THREE.BoxGeometry(0.08, 0.04, 0.05);
                const eyeSlitMaterial = new THREE.MeshBasicMaterial({ color: 0x6699FF });
                const eyeSlit1 = new THREE.Mesh(eyeSlitGeometry, eyeSlitMaterial);
                eyeSlit1.position.set(-0.08, 1.52, 0.38);
                group.add(eyeSlit1);
                const eyeSlit2 = new THREE.Mesh(eyeSlitGeometry, eyeSlitMaterial);
                eyeSlit2.position.set(0.08, 1.52, 0.38);
                group.add(eyeSlit2);

                // Helmet plume
                const plumeGeometry = new THREE.ConeGeometry(0.12, 0.5, 8);
                const plumeMaterial = new THREE.MeshLambertMaterial({ color: plumageColor });
                const plume = new THREE.Mesh(plumeGeometry, plumeMaterial);
                plume.position.set(0, 1.95, -0.1);
                plume.rotation.x = 0.3;
                group.add(plume);

                // Armored arms
                const armGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.55, 8);
                const armMaterial = new THREE.MeshLambertMaterial({ color: chainmailColor });
                const arm1 = new THREE.Mesh(armGeometry, armMaterial);
                arm1.position.set(-0.45, 0.7, 0);
                arm1.rotation.z = 0.3;
                group.add(arm1);
                const arm2 = new THREE.Mesh(armGeometry, armMaterial);
                arm2.position.set(0.45, 0.7, 0);
                arm2.rotation.z = -0.3;
                group.add(arm2);

                // Shield (left hand)
                const shieldGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.08);
                const shieldMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shield.position.set(-0.7, 0.6, 0.2);
                shield.rotation.y = 0.3;
                group.add(shield);

                // Shield emblem
                const emblemGeometry = new THREE.CircleGeometry(0.1, 8);
                const emblemMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const emblem = new THREE.Mesh(emblemGeometry, emblemMaterial);
                emblem.position.set(-0.68, 0.6, 0.26);
                emblem.rotation.y = 0.3;
                group.add(emblem);

                // Sword (right hand)
                const swordBladeGeometry = new THREE.BoxGeometry(0.06, 0.6, 0.02);
                const swordBladeMaterial = new THREE.MeshLambertMaterial({ color: 0x9a9aaa });
                const swordBlade = new THREE.Mesh(swordBladeGeometry, swordBladeMaterial);
                swordBlade.position.set(0.7, 0.9, 0.15);
                swordBlade.rotation.z = -0.3;
                group.add(swordBlade);

                // Armored legs
                const legGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.5, 8);
                const legMaterial = new THREE.MeshLambertMaterial({ color: chainmailColor });
                const leg1 = new THREE.Mesh(legGeometry, legMaterial);
                leg1.position.set(-0.18, 0.25, 0);
                group.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, legMaterial);
                leg2.position.set(0.18, 0.25, 0);
                group.add(leg2);

                return group;
            },

            'spectral-knight': function() {
                const group = new THREE.Group();
                const ghostArmor = 0x5a6a8a;
                const ghostGlow = 0x4488cc;
                const etherealBlue = 0x6699cc;

                // Spectral armored body
                const bodyGeometry = new THREE.BoxGeometry(0.8, 1.1, 0.5);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: ghostArmor,
                    transparent: true,
                    opacity: 0.7,
                    emissive: ghostGlow,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.0;
                group.add(body);

                // Chest plate detail
                const chestGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.15);
                const chestMaterial = new THREE.MeshPhongMaterial({
                    color: 0x4a5a7a,
                    transparent: true,
                    opacity: 0.8,
                    emissive: ghostGlow,
                    emissiveIntensity: 0.15
                });
                const chestPlate = new THREE.Mesh(chestGeometry, chestMaterial);
                chestPlate.position.set(0, 1.05, 0.28);
                group.add(chestPlate);

                // Ghostly helmet
                const helmetGeometry = new THREE.SphereGeometry(0.45, 16, 16);
                const helmetMaterial = new THREE.MeshPhongMaterial({
                    color: ghostArmor,
                    transparent: true,
                    opacity: 0.75,
                    emissive: ghostGlow,
                    emissiveIntensity: 0.2
                });
                const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
                helmet.position.y = 1.9;
                group.add(helmet);

                // Helmet visor (dark slit)
                const visorGeometry = new THREE.BoxGeometry(0.35, 0.12, 0.12);
                const visorMaterial = new THREE.MeshBasicMaterial({ color: 0x0a0a1a });
                const visor = new THREE.Mesh(visorGeometry, visorMaterial);
                visor.position.set(0, 1.85, 0.38);
                group.add(visor);

                // Glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x44AAFF });
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.1, 1.87, 0.42);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.1, 1.87, 0.42);
                group.add(eye2);

                // Helmet crest
                const crestGeometry = new THREE.ConeGeometry(0.15, 0.6, 8);
                const crestMaterial = new THREE.MeshPhongMaterial({
                    color: etherealBlue,
                    transparent: true,
                    opacity: 0.6,
                    emissive: ghostGlow,
                    emissiveIntensity: 0.3
                });
                const crest = new THREE.Mesh(crestGeometry, crestMaterial);
                crest.position.set(0, 2.4, -0.1);
                crest.rotation.x = 0.3;
                group.add(crest);

                // Ghostly arms
                const armGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.7, 8);
                const armMaterial = new THREE.MeshPhongMaterial({
                    color: ghostArmor,
                    transparent: true,
                    opacity: 0.6,
                    emissive: ghostGlow,
                    emissiveIntensity: 0.15
                });
                const arm1 = new THREE.Mesh(armGeometry, armMaterial);
                arm1.position.set(-0.55, 0.9, 0);
                arm1.rotation.z = 0.3;
                group.add(arm1);
                const arm2 = new THREE.Mesh(armGeometry, armMaterial);
                arm2.position.set(0.55, 0.9, 0);
                arm2.rotation.z = -0.3;
                group.add(arm2);

                // Ghostly shield
                const shieldGeometry = new THREE.BoxGeometry(0.5, 0.6, 0.08);
                const shieldMaterial = new THREE.MeshPhongMaterial({
                    color: 0x3a4a6a,
                    transparent: true,
                    opacity: 0.65,
                    emissive: ghostGlow,
                    emissiveIntensity: 0.2
                });
                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shield.position.set(-0.85, 0.8, 0.25);
                shield.rotation.y = 0.4;
                group.add(shield);

                // Spectral sword
                const swordBladeGeometry = new THREE.BoxGeometry(0.08, 0.8, 0.03);
                const swordBladeMaterial = new THREE.MeshPhongMaterial({
                    color: etherealBlue,
                    transparent: true,
                    opacity: 0.7,
                    emissive: ghostGlow,
                    emissiveIntensity: 0.4
                });
                const swordBlade = new THREE.Mesh(swordBladeGeometry, swordBladeMaterial);
                swordBlade.position.set(0.8, 1.1, 0.2);
                swordBlade.rotation.z = -0.3;
                group.add(swordBlade);

                // Ethereal mist at base
                const mistGeometry = new THREE.ConeGeometry(0.6, 1.0, 8);
                const mistMaterial = new THREE.MeshPhongMaterial({
                    color: etherealBlue,
                    transparent: true,
                    opacity: 0.3,
                    emissive: ghostGlow,
                    emissiveIntensity: 0.2,
                    side: THREE.DoubleSide
                });
                const mist = new THREE.Mesh(mistGeometry, mistMaterial);
                mist.position.y = 0.2;
                mist.rotation.x = Math.PI;
                group.add(mist);

                return group;
            },

            'giant-spider': function() {
                const group = new THREE.Group();
                const spiderBlack = 0x1a1a1a;
                const spiderBrown = 0x3a2a1a;
                const spiderEyes = 0x880000;

                // Large bulbous abdomen
                const abdomenGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const abdomenMaterial = new THREE.MeshLambertMaterial({ color: spiderBlack });
                const abdomen = new THREE.Mesh(abdomenGeometry, abdomenMaterial);
                abdomen.position.set(0, 1.8, -1.2);
                abdomen.scale.set(1.3, 1, 1.5);
                group.add(abdomen);

                // Red hourglass marking
                const markingGeometry = new THREE.CircleGeometry(0.3, 6);
                const markingMaterial = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
                const marking1 = new THREE.Mesh(markingGeometry, markingMaterial);
                marking1.position.set(0, 2.0, -2.4);
                marking1.rotation.x = -0.3;
                group.add(marking1);
                const marking2 = new THREE.Mesh(markingGeometry, markingMaterial);
                marking2.position.set(0, 1.5, -2.5);
                marking2.rotation.x = -0.3;
                group.add(marking2);

                // Cephalothorax (head-body segment)
                const cephalothoraxGeometry = new THREE.SphereGeometry(1.0, 16, 16);
                const cephalothoraxMaterial = new THREE.MeshLambertMaterial({ color: spiderBrown });
                const cephalothorax = new THREE.Mesh(cephalothoraxGeometry, cephalothoraxMaterial);
                cephalothorax.position.set(0, 2.0, 0.8);
                cephalothorax.scale.set(1.2, 0.9, 1.4);
                group.add(cephalothorax);

                // Main eyes (front, larger)
                const eyeGeometry = new THREE.SphereGeometry(0.18, 12, 12);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: spiderEyes });
                const mainEye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                mainEye1.position.set(-0.3, 2.2, 1.5);
                group.add(mainEye1);
                const mainEye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                mainEye2.position.set(0.3, 2.2, 1.5);
                group.add(mainEye2);

                // Secondary eyes (smaller)
                const smallEyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const smallEye1 = new THREE.Mesh(smallEyeGeometry, eyeMaterial);
                smallEye1.position.set(-0.6, 2.1, 1.3);
                group.add(smallEye1);
                const smallEye2 = new THREE.Mesh(smallEyeGeometry, eyeMaterial);
                smallEye2.position.set(0.6, 2.1, 1.3);
                group.add(smallEye2);
                const smallEye3 = new THREE.Mesh(smallEyeGeometry, eyeMaterial);
                smallEye3.position.set(-0.4, 2.5, 1.2);
                group.add(smallEye3);
                const smallEye4 = new THREE.Mesh(smallEyeGeometry, eyeMaterial);
                smallEye4.position.set(0.4, 2.5, 1.2);
                group.add(smallEye4);

                // Fangs
                const fangGeometry = new THREE.ConeGeometry(0.1, 0.5, 6);
                const fangMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const fang1 = new THREE.Mesh(fangGeometry, fangMaterial);
                fang1.position.set(-0.18, 1.7, 1.6);
                fang1.rotation.x = 0.5;
                fang1.rotation.z = 0.2;
                group.add(fang1);
                const fang2 = new THREE.Mesh(fangGeometry, fangMaterial);
                fang2.position.set(0.18, 1.7, 1.6);
                fang2.rotation.x = 0.5;
                fang2.rotation.z = -0.2;
                group.add(fang2);

                // 8 Spider legs
                const legMaterial = new THREE.MeshLambertMaterial({ color: spiderBlack });
                const legAngles = [0.4, 0.15, -0.1, -0.35];
                const legOffsets = [0.6, 0.3, 0, -0.3];

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 4; i++) {
                        // First segment
                        const seg1Geometry = new THREE.CylinderGeometry(0.1, 0.08, 1.8, 6);
                        const seg1 = new THREE.Mesh(seg1Geometry, legMaterial);
                        seg1.position.set(side * 0.9, 2.0, legOffsets[i]);
                        seg1.rotation.z = side * 0.8;
                        seg1.rotation.y = legAngles[i];
                        group.add(seg1);

                        // Second segment
                        const seg2Geometry = new THREE.CylinderGeometry(0.08, 0.05, 2.0, 6);
                        const seg2 = new THREE.Mesh(seg2Geometry, legMaterial);
                        seg2.position.set(side * 2.0, 2.8, legOffsets[i] + legAngles[i] * 1.5);
                        seg2.rotation.z = side * -0.6;
                        group.add(seg2);

                        // Third segment
                        const seg3Geometry = new THREE.CylinderGeometry(0.05, 0.03, 1.4, 6);
                        const seg3 = new THREE.Mesh(seg3Geometry, legMaterial);
                        seg3.position.set(side * 2.5, 0.7, legOffsets[i] + legAngles[i] * 2);
                        seg3.rotation.z = side * 0.1;
                        group.add(seg3);
                    }
                }

                return group;
            },

            'dark-sorcerer': function() {
                const group = new THREE.Group();
                const robeBlack = 0x1a1a2a;
                const robeDark = 0x2a2a3a;
                const magicPurple = 0x6622aa;
                const magicGlow = 0x8844cc;

                // Dark hooded robe body
                const bodyGeometry = new THREE.CylinderGeometry(0.55, 1.0, 2.4, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: robeBlack });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.4;
                group.add(body);

                // Robe folds
                for (let i = 0; i < 6; i++) {
                    const foldGeometry = new THREE.BoxGeometry(0.15, 2.2, 0.08);
                    const foldMaterial = new THREE.MeshLambertMaterial({ color: robeDark });
                    const fold = new THREE.Mesh(foldGeometry, foldMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    fold.position.set(Math.cos(angle) * 0.75, 1.2, Math.sin(angle) * 0.75);
                    fold.rotation.y = angle;
                    group.add(fold);
                }

                // Ragged robe bottom
                for (let i = 0; i < 10; i++) {
                    const ragGeometry = new THREE.ConeGeometry(0.12, 0.5, 4);
                    const ragMaterial = new THREE.MeshLambertMaterial({ color: 0x0a0a15 });
                    const rag = new THREE.Mesh(ragGeometry, ragMaterial);
                    const angle = (i / 10) * Math.PI * 2;
                    rag.position.set(Math.cos(angle) * 0.9, 0.2, Math.sin(angle) * 0.9);
                    rag.rotation.x = Math.PI;
                    group.add(rag);
                }

                // Deep hood
                const hoodGeometry = new THREE.SphereGeometry(0.45, 16, 16);
                const hoodMaterial = new THREE.MeshLambertMaterial({ color: robeBlack });
                const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
                hood.position.y = 2.75;
                hood.scale.z = 1.2;
                group.add(hood);

                // Dark void face
                const faceGeometry = new THREE.SphereGeometry(0.35, 12, 12);
                const faceMaterial = new THREE.MeshBasicMaterial({ color: 0x000005 });
                const face = new THREE.Mesh(faceGeometry, faceMaterial);
                face.position.set(0, 2.7, 0.25);
                face.scale.z = 0.7;
                group.add(face);

                // Glowing purple eyes
                const eyeGeometry = new THREE.SphereGeometry(0.07, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: magicPurple });
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.12, 2.73, 0.42);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.12, 2.73, 0.42);
                group.add(eye2);

                // Dark magic staff
                const staffGeometry = new THREE.CylinderGeometry(0.04, 0.05, 2.8, 8);
                const staffMaterial = new THREE.MeshLambertMaterial({ color: 0x1a0a1a });
                const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                staff.position.set(0.6, 1.6, 0.25);
                staff.rotation.z = -0.1;
                group.add(staff);

                // Staff head - twisted metal
                const staffHeadGeometry = new THREE.TorusKnotGeometry(0.12, 0.03, 32, 8, 2, 3);
                const staffHeadMaterial = new THREE.MeshLambertMaterial({ color: 0x2a1a2a });
                const staffHead = new THREE.Mesh(staffHeadGeometry, staffHeadMaterial);
                staffHead.position.set(0.55, 3.0, 0.25);
                staffHead.rotation.x = Math.PI / 2;
                group.add(staffHead);

                // Magic orb in staff head
                const orbGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: magicGlow, transparent: true, opacity: 0.85 });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.set(0.55, 3.0, 0.25);
                group.add(orb);

                // Floating spell book
                const bookGeometry = new THREE.BoxGeometry(0.25, 0.3, 0.08);
                const bookMaterial = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
                const book = new THREE.Mesh(bookGeometry, bookMaterial);
                book.position.set(-0.65, 2.0, 0.3);
                book.rotation.y = 0.3;
                book.rotation.z = -0.1;
                group.add(book);

                // Book pages
                const pagesGeometry = new THREE.BoxGeometry(0.2, 0.25, 0.06);
                const pagesMaterial = new THREE.MeshLambertMaterial({ color: 0xd0c0a0 });
                const pages = new THREE.Mesh(pagesGeometry, pagesMaterial);
                pages.position.set(-0.64, 2.0, 0.31);
                pages.rotation.y = 0.3;
                pages.rotation.z = -0.1;
                group.add(pages);

                // Magic particles
                const particleMaterial = new THREE.MeshBasicMaterial({ color: magicGlow, transparent: true, opacity: 0.5 });
                for (let i = 0; i < 5; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.03 + Math.random() * 0.02, 6, 6);
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = (i / 5) * Math.PI * 2;
                    particle.position.set(0.55 + Math.cos(angle) * 0.25, 2.8 + Math.sin(angle) * 0.25, 0.25);
                    group.add(particle);
                }

                return group;
            },

            'raven': function() {
                const group = new THREE.Group();
                const ravenBlack = 0x0a0a0a;

                // Bird body
                const bodyGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: ravenBlack });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);

                // Wings
                const wingGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.4);
                const wingMaterial = new THREE.MeshLambertMaterial({ color: 0x050505 });
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.6, 0, 0);
                group.add(leftWing);
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.6, 0, 0);
                group.add(rightWing);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.set(0, 0.15, -0.35);
                group.add(head);

                // Beak
                const beakGeometry = new THREE.ConeGeometry(0.1, 0.35, 6);
                const beakMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                beak.rotation.z = -Math.PI / 2;
                beak.position.set(0, 0.12, -0.55);
                group.add(beak);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(-0.12, 0.2, -0.5);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(0.12, 0.2, -0.5);
                group.add(eye2);

                // Tail feathers
                const tailGeometry = new THREE.ConeGeometry(0.2, 0.5, 4);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.position.set(0, -0.1, 0.5);
                tail.rotation.x = Math.PI / 2;
                group.add(tail);

                return group;
            },

            'stone-dragon': function() {
                const group = new THREE.Group();
                const stoneColor = 0x4A5A4A;
                const stoneDark = 0x3A4A3A;

                // Body - long segmented shape
                const bodyGeometry = new THREE.CylinderGeometry(0.8, 1.0, 4, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: stoneColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                body.position.x = 2;
                group.add(body);

                // Body scales
                for (let i = 0; i < 5; i++) {
                    const scaleGeometry = new THREE.ConeGeometry(0.25, 0.5, 6);
                    const scaleMaterial = new THREE.MeshLambertMaterial({ color: stoneDark });
                    const scale = new THREE.Mesh(scaleGeometry, scaleMaterial);
                    scale.position.set(i * 0.8, 1.1, 0);
                    group.add(scale);
                }

                // Neck
                const neckGeometry = new THREE.CylinderGeometry(0.7, 0.8, 1.6, 8);
                const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
                neck.rotation.z = Math.PI / 2;
                neck.position.x = 4;
                neck.position.y = 0.4;
                group.add(neck);

                // Head
                const headGeometry = new THREE.ConeGeometry(1.0, 2.0, 8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.rotation.z = -Math.PI / 2;
                head.position.x = 5.2;
                head.position.y = 0.6;
                group.add(head);

                // Jaw
                const jawGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.8);
                const jaw = new THREE.Mesh(jawGeometry, bodyMaterial);
                jaw.position.set(5.6, 0.2, 0);
                group.add(jaw);

                // Eyes - fiery orange
                const eyeGeometry = new THREE.SphereGeometry(0.25, 16, 16);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4500 });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(5.4, 1.0, 0.5);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(5.4, 1.0, -0.5);
                group.add(rightEye);

                // Wings
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0);
                wingShape.lineTo(2.5, 0.8);
                wingShape.lineTo(3.2, 0);
                wingShape.lineTo(2.5, -0.8);
                wingShape.lineTo(1.5, -0.4);
                wingShape.lineTo(0, 0);

                const wingGeometry = new THREE.ShapeGeometry(wingShape);
                const wingMaterial = new THREE.MeshLambertMaterial({ color: stoneDark, side: THREE.DoubleSide });

                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(1.2, 1.2, 0);
                leftWing.rotation.y = Math.PI / 2;
                group.add(leftWing);

                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(1.2, 1.2, 0);
                rightWing.rotation.y = -Math.PI / 2;
                rightWing.scale.z = -1;
                group.add(rightWing);

                // Tail
                const tailGeometry = new THREE.ConeGeometry(0.5, 3, 8);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.rotation.z = Math.PI / 2;
                tail.position.set(-1.5, 0, 0);
                group.add(tail);

                // Tail spike
                const spikeGeometry = new THREE.ConeGeometry(0.3, 0.8, 4);
                const spike = new THREE.Mesh(spikeGeometry, new THREE.MeshLambertMaterial({ color: stoneDark }));
                spike.rotation.z = -Math.PI / 2;
                spike.position.set(-3.2, 0, 0);
                group.add(spike);

                return group;
            },

            // ========== LEVEL 9 - COMPUTER/SYSTEM CORE MOBS ==========

            'bug': function() {
                const group = new THREE.Group();
                const bugColor = 0x00FF00;
                const darkColor = 0x003300;

                // Glitchy pixelated body
                const bodyGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.4);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: bugColor, transparent: true, opacity: 0.8 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.7;
                group.add(body);

                // Pixel head 
                const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.4);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.3;
                group.add(head);

                // Red error eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const eyeGeometry = new THREE.BoxGeometry(0.12, 0.12, 0.1);
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.35, 0.22);
                    group.add(eye);
                });

                // Antenna (error flags)
                const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);
                const antennaMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                [-0.15, 0.15].forEach(x => {
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.set(x, 1.7, 0);
                    group.add(antenna);
                });

                // Glitch particles around
                for (let i = 0; i < 6; i++) {
                    const glitchGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const glitchMaterial = new THREE.MeshBasicMaterial({ color: [0x00FF00, 0xFF0000, 0x00FFFF][i % 3] });
                    const glitch = new THREE.Mesh(glitchGeometry, glitchMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    glitch.position.set(Math.cos(angle) * 0.6, 0.8 + (i % 3) * 0.3, Math.sin(angle) * 0.4);
                    group.add(glitch);
                }

                return group;
            },

            'firewall-sentry': function() {
                const group = new THREE.Group();
                const neonBlue = 0x00AAFF;
                const darkBlue = 0x001144;

                // Shield body core
                const bodyGeometry = new THREE.BoxGeometry(0.9, 1.2, 0.5);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: darkBlue });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.0;
                group.add(body);

                // Glowing shield panels
                const shieldMaterial = new THREE.MeshBasicMaterial({ color: neonBlue, transparent: true, opacity: 0.7 });
                const shieldGeometry = new THREE.BoxGeometry(0.1, 1.0, 0.4);
                [-0.5, 0.5].forEach(x => {
                    const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                    shield.position.set(x, 1.0, 0);
                    group.add(shield);
                });

                // Head with scanner
                const headGeometry = new THREE.SphereGeometry(0.45, 12, 12);
                const headMaterial = new THREE.MeshLambertMaterial({ color: darkBlue });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.0;
                group.add(head);

                // Scanner visor
                const visorGeometry = new THREE.BoxGeometry(0.6, 0.15, 0.1);
                const visorMaterial = new THREE.MeshBasicMaterial({ color: neonBlue });
                const visor = new THREE.Mesh(visorGeometry, visorMaterial);
                visor.position.set(0, 2.0, 0.4);
                group.add(visor);

                // LED indicators
                for (let i = 0; i < 4; i++) {
                    const ledGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                    const ledMaterial = new THREE.MeshBasicMaterial({ color: [0x00FF00, 0xFF0000][i % 2] });
                    const led = new THREE.Mesh(ledGeometry, ledMaterial);
                    led.position.set(-0.2 + i * 0.15, 0.5, 0.28);
                    group.add(led);
                }

                return group;
            },

            'mainframe': function() {
                const group = new THREE.Group();
                const serverColor = 0x0A0A2E;
                const neonCyan = 0x00FFFF;
                const neonMagenta = 0xFF00FF;

                // Main server tower body
                const bodyGeometry = new THREE.BoxGeometry(2.0, 3.5, 1.5);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: serverColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 2.0;
                group.add(body);

                // Vertical LED strips
                const stripMaterial1 = new THREE.MeshBasicMaterial({ color: neonCyan });
                const stripMaterial2 = new THREE.MeshBasicMaterial({ color: neonMagenta });
                for (let i = 0; i < 3; i++) {
                    const stripGeometry = new THREE.BoxGeometry(0.08, 3.2, 0.1);
                    const strip = new THREE.Mesh(stripGeometry, [stripMaterial1, stripMaterial2, stripMaterial1][i]);
                    strip.position.set(-0.6 + i * 0.6, 2.0, 0.8);
                    group.add(strip);
                }

                // Blinking status lights
                for (let i = 0; i < 8; i++) {
                    const lightGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                    const lightColor = [0xFF0000, 0x00FF00, 0xFFFF00][Math.floor(Math.random() * 3)];
                    const lightMaterial = new THREE.MeshBasicMaterial({ color: lightColor });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(-0.7 + (i % 4) * 0.45, 3.5 + Math.floor(i / 4) * 0.3, 0.8);
                    group.add(light);
                }

                // Cooling vents
                for (let i = 0; i < 3; i++) {
                    const ventGeometry = new THREE.BoxGeometry(1.6, 0.15, 0.1);
                    const ventMaterial = new THREE.MeshLambertMaterial({ color: 0x1A1A3E });
                    const vent = new THREE.Mesh(ventGeometry, ventMaterial);
                    vent.position.set(0, 0.8 + i * 0.3, 0.8);
                    group.add(vent);
                }

                // Core processing unit (glowing center)
                const coreGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const coreMaterial = new THREE.MeshBasicMaterial({ color: neonCyan, transparent: true, opacity: 0.8 });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 2.0;
                group.add(core);

                return group;
            },

            'hacker': function() {
                const group = new THREE.Group();
                const darkGray = 0x1A1A1A;
                const neonGreen = 0x00FF00;

                // Hooded robe body
                const bodyGeometry = new THREE.ConeGeometry(0.6, 1.8, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: darkGray });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.2;
                group.add(body);

                // Hood
                const hoodGeometry = new THREE.SphereGeometry(0.45, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const hoodMaterial = new THREE.MeshLambertMaterial({ color: darkGray });
                const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
                hood.position.y = 2.2;
                hood.rotation.x = -0.4;
                group.add(hood);

                // Glowing eyes in shadow
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: neonGreen });
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 2.1, 0.3);
                    group.add(eye);
                });

                // Holographic screen in front
                const screenGeometry = new THREE.PlaneGeometry(0.8, 0.6);
                const screenMaterial = new THREE.MeshBasicMaterial({ 
                    color: neonGreen, 
                    transparent: true, 
                    opacity: 0.4, 
                    side: THREE.DoubleSide 
                });
                const screen = new THREE.Mesh(screenGeometry, screenMaterial);
                screen.position.set(0, 1.5, 0.8);
                group.add(screen);

                // Matrix-like code lines on screen
                for (let i = 0; i < 5; i++) {
                    const codeGeometry = new THREE.BoxGeometry(0.6, 0.03, 0.01);
                    const codeMaterial = new THREE.MeshBasicMaterial({ color: 0x00AA00 });
                    const code = new THREE.Mesh(codeGeometry, codeMaterial);
                    code.position.set(0, 1.35 + i * 0.12, 0.82);
                    group.add(code);
                }

                return group;
            },

            'surveillance-drone': function() {
                const group = new THREE.Group();
                const droneColor = 0x2A2A3A;
                const neonRed = 0xFF0000;

                // Main body - disc shape
                const bodyGeometry = new THREE.CylinderGeometry(0.8, 0.6, 0.4, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: droneColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                group.add(body);

                // Scanner eye in center
                const eyeGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: neonRed });
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye.position.set(0, 1.35, 0);
                group.add(eye);

                // Rotating scanner ring
                const ringGeometry = new THREE.TorusGeometry(0.5, 0.05, 8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = 1.5;
                ring.rotation.x = Math.PI / 2;
                group.add(ring);

                // Propeller arms
                for (let i = 0; i < 4; i++) {
                    const armGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.6);
                    const armMaterial = new THREE.MeshLambertMaterial({ color: droneColor });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    const angle = (i / 4) * Math.PI * 2;
                    arm.position.set(Math.cos(angle) * 0.9, 1.5, Math.sin(angle) * 0.9);
                    arm.rotation.y = angle;
                    group.add(arm);

                    // Propeller
                    const propGeometry = new THREE.CircleGeometry(0.15, 8);
                    const propMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                    const prop = new THREE.Mesh(propGeometry, propMaterial);
                    prop.position.set(Math.cos(angle) * 1.1, 1.55, Math.sin(angle) * 1.1);
                    prop.rotation.x = Math.PI / 2;
                    group.add(prop);
                }

                // Status lights
                const lightPositions = [[0.35, 0], [-0.35, 0], [0, 0.35], [0, -0.35]];
                lightPositions.forEach((pos, i) => {
                    const lightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({ color: [0xFF0000, 0x00FF00][i % 2] });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(pos[0], 1.7, pos[1]);
                    group.add(light);
                });

                return group;
            },

            'trojan-dragon': function() {
                const group = new THREE.Group();
                const glitchPurple = 0x9900FF;
                const glitchCyan = 0x00FFFF;
                const darkCore = 0x110022;

                // Body - corrupted data shape
                const bodyGeometry = new THREE.CylinderGeometry(0.7, 1.0, 4, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: darkCore });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                body.position.x = 2;
                group.add(body);

                // Glitch corruption particles on body
                for (let i = 0; i < 8; i++) {
                    const glitchGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                    const glitchMaterial = new THREE.MeshBasicMaterial({ color: [glitchPurple, glitchCyan][i % 2], transparent: true, opacity: 0.7 });
                    const glitch = new THREE.Mesh(glitchGeometry, glitchMaterial);
                    glitch.position.set(i * 0.5, Math.sin(i) * 0.8 + 0.3, Math.cos(i) * 0.6);
                    group.add(glitch);
                }

                // Neck
                const neckGeometry = new THREE.CylinderGeometry(0.6, 0.7, 1.4, 8);
                const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
                neck.rotation.z = Math.PI / 2;
                neck.position.set(4, 0.4, 0);
                group.add(neck);

                // Head
                const headGeometry = new THREE.ConeGeometry(0.9, 1.8, 8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.rotation.z = -Math.PI / 2;
                head.position.set(5.0, 0.6, 0);
                group.add(head);

                // Glowing digital eyes
                const eyeGeometry = new THREE.SphereGeometry(0.22, 16, 16);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF00FF });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(5.2, 1.0, 0.45);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(5.2, 1.0, -0.45);
                group.add(rightEye);

                // Glitched wings
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0);
                wingShape.lineTo(2.2, 0.7);
                wingShape.lineTo(2.8, 0);
                wingShape.lineTo(2.2, -0.7);
                wingShape.lineTo(1.3, -0.3);
                wingShape.lineTo(0, 0);

                const wingGeometry = new THREE.ShapeGeometry(wingShape);
                const wingMaterial = new THREE.MeshBasicMaterial({ color: glitchPurple, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });

                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(1.0, 1.2, 0);
                leftWing.rotation.y = Math.PI / 2;
                group.add(leftWing);

                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(1.0, 1.2, 0);
                rightWing.rotation.y = -Math.PI / 2;
                rightWing.scale.z = -1;
                group.add(rightWing);

                // Digital flame breath particles
                for (let i = 0; i < 5; i++) {
                    const flameGeometry = new THREE.SphereGeometry(0.15 - i * 0.02, 8, 8);
                    const flameMaterial = new THREE.MeshBasicMaterial({ color: [0xFF00FF, 0x00FFFF, 0xFF00FF][i % 3], transparent: true, opacity: 0.7 });
                    const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                    flame.position.set(6.0 + i * 0.3, 0.5, 0);
                    group.add(flame);
                }

                // Tail with data corruption
                const tailGeometry = new THREE.ConeGeometry(0.5, 2.8, 8);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.rotation.z = Math.PI / 2;
                tail.position.set(-1.3, 0, 0);
                group.add(tail);

                return group;
            },

            // ========== LEVEL 9 ENVIRONMENT ==========

            'server-rack': function() {
                const group = new THREE.Group();
                const rackColor = 0x0A0A1A;
                const neonCyan = 0x00FFFF;
                const neonMagenta = 0xFF00FF;

                // Main rack body
                const rackGeometry = new THREE.BoxGeometry(2.0, 3.0, 0.4);
                const rackMaterial = new THREE.MeshLambertMaterial({ color: rackColor });
                const rack = new THREE.Mesh(rackGeometry, rackMaterial);
                rack.position.y = 1.5;
                group.add(rack);

                // LED strips
                for (let i = 0; i < 3; i++) {
                    const stripGeometry = new THREE.BoxGeometry(0.05, 2.8, 0.1);
                    const stripMaterial = new THREE.MeshBasicMaterial({ color: [neonCyan, neonMagenta, 0x00FF00][i] });
                    const strip = new THREE.Mesh(stripGeometry, stripMaterial);
                    strip.position.set(-0.7 + i * 0.7, 1.5, 0.25);
                    group.add(strip);
                }

                // Blinking lights
                for (let i = 0; i < 10; i++) {
                    const lightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({ color: [0xFF0000, 0x00FF00][i % 2] });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(-0.8 + (i % 5) * 0.4, 2.8 - Math.floor(i / 5) * 0.3, 0.25);
                    group.add(light);
                }

                return group;
            },

            'data-stream': function() {
                const group = new THREE.Group();
                const streamColor = 0x00FFFF;

                // Base stream channel
                const baseGeometry = new THREE.BoxGeometry(3.0, 0.1, 0.8);
                const baseMaterial = new THREE.MeshBasicMaterial({ color: 0x002222 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.05;
                group.add(base);

                // Flowing data packets
                for (let i = 0; i < 8; i++) {
                    const packetGeometry = new THREE.BoxGeometry(0.2, 0.15, 0.15);
                    const packetMaterial = new THREE.MeshBasicMaterial({ color: streamColor, transparent: true, opacity: 0.7 });
                    const packet = new THREE.Mesh(packetGeometry, packetMaterial);
                    packet.position.set(-1.2 + i * 0.35, 0.15, (i % 3 - 1) * 0.25);
                    group.add(packet);
                }

                // Glow effect
                const glowGeometry = new THREE.BoxGeometry(3.0, 0.3, 0.8);
                const glowMaterial = new THREE.MeshBasicMaterial({ color: streamColor, transparent: true, opacity: 0.2 });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 0.2;
                group.add(glow);

                return group;
            },

            'firewall-gate': function() {
                const group = new THREE.Group();
                const gateColor = 0x00AAFF;

                // Gate frame posts
                const postGeometry = new THREE.BoxGeometry(0.2, 2.5, 0.2);
                const postMaterial = new THREE.MeshLambertMaterial({ color: 0x1A1A3A });
                [-0.8, 0.8].forEach(x => {
                    const post = new THREE.Mesh(postGeometry, postMaterial);
                    post.position.set(x, 1.25, 0);
                    group.add(post);
                });

                // Energy barrier (pulsing)
                const barrierGeometry = new THREE.PlaneGeometry(1.4, 2.3);
                const barrierMaterial = new THREE.MeshBasicMaterial({ 
                    color: gateColor, 
                    transparent: true, 
                    opacity: 0.5, 
                    side: THREE.DoubleSide 
                });
                const barrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                barrier.position.y = 1.25;
                group.add(barrier);

                // Horizontal scan lines
                for (let i = 0; i < 5; i++) {
                    const lineGeometry = new THREE.BoxGeometry(1.3, 0.03, 0.05);
                    const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.position.set(0, 0.4 + i * 0.45, 0.02);
                    group.add(line);
                }

                return group;
            },

            'circuit-ground': function() {
                const group = new THREE.Group();
                const groundColor = 0x000808;
                const gridColor = 0x00FFFF;

                // Base ground
                const groundGeometry = new THREE.PlaneGeometry(4, 4);
                const groundMaterial = new THREE.MeshBasicMaterial({ color: groundColor, side: THREE.DoubleSide });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                group.add(ground);

                // Circuit grid lines
                for (let i = 0; i < 5; i++) {
                    const hLineGeometry = new THREE.BoxGeometry(4, 0.02, 0.02);
                    const hLineMaterial = new THREE.MeshBasicMaterial({ color: gridColor });
                    const hLine = new THREE.Mesh(hLineGeometry, hLineMaterial);
                    hLine.position.set(0, 0.01, -2 + i);
                    group.add(hLine);

                    const vLineGeometry = new THREE.BoxGeometry(0.02, 0.02, 4);
                    const vLine = new THREE.Mesh(vLineGeometry, hLineMaterial);
                    vLine.position.set(-2 + i, 0.01, 0);
                    group.add(vLine);
                }

                // Circuit nodes at intersections
                for (let x = 0; x < 3; x++) {
                    for (let z = 0; z < 3; z++) {
                        const nodeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                        const nodeMaterial = new THREE.MeshBasicMaterial({ color: gridColor });
                        const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                        node.position.set(-1 + x, 0.03, -1 + z);
                        group.add(node);
                    }
                }

                return group;
            },

            // ========== LEVEL 9 HAZARDS ==========

            'buffer-overflow': function() {
                const group = new THREE.Group();
                const dangerRed = 0xFF0000;

                // Glitchy expanding zone
                const zoneGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.1, 16);
                const zoneMaterial = new THREE.MeshBasicMaterial({ color: dangerRed, transparent: true, opacity: 0.3 });
                const zone = new THREE.Mesh(zoneGeometry, zoneMaterial);
                zone.position.y = 0.05;
                group.add(zone);

                // Inner core
                const coreGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 12);
                const coreMaterial = new THREE.MeshBasicMaterial({ color: dangerRed, transparent: true, opacity: 0.7 });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 0.1;
                group.add(core);

                // Glitch particles
                for (let i = 0; i < 8; i++) {
                    const glitchGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                    const glitchMaterial = new THREE.MeshBasicMaterial({ color: [0xFF0000, 0xFF00FF, 0x00FFFF][i % 3] });
                    const glitch = new THREE.Mesh(glitchGeometry, glitchMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    glitch.position.set(Math.cos(angle) * 1.0, 0.2, Math.sin(angle) * 1.0);
                    group.add(glitch);
                }

                return group;
            },

            'virus-strike': function() {
                const group = new THREE.Group();

                // Warning zone (yellow)
                const warningGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.05, 16);
                const warningMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.5 });
                const warning = new THREE.Mesh(warningGeometry, warningMaterial);
                warning.position.y = 0.025;
                group.add(warning);

                // Danger zone (red inner)
                const dangerGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 12);
                const dangerMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000, transparent: true, opacity: 0.7 });
                const danger = new THREE.Mesh(dangerGeometry, dangerMaterial);
                danger.position.y = 0.05;
                group.add(danger);

                // Target crosshairs
                const crossMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const hCrossGeometry = new THREE.BoxGeometry(2.0, 0.02, 0.05);
                const hCross = new THREE.Mesh(hCrossGeometry, crossMaterial);
                hCross.position.y = 0.1;
                group.add(hCross);

                const vCrossGeometry = new THREE.BoxGeometry(0.05, 0.02, 2.0);
                const vCross = new THREE.Mesh(vCrossGeometry, crossMaterial);
                vCross.position.y = 0.1;
                group.add(vCross);

                return group;
            },

            'system-blackout': function() {
                const group = new THREE.Group();

                // Dark cloud representing blackout
                const cloudGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8 });
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.y = 1.0;
                cloud.scale.set(1, 0.5, 1);
                group.add(cloud);

                // Static noise particles
                for (let i = 0; i < 20; i++) {
                    const noiseGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const noiseMaterial = new THREE.MeshBasicMaterial({ color: [0xFFFFFF, 0x888888][i % 2] });
                    const noise = new THREE.Mesh(noiseGeometry, noiseMaterial);
                    noise.position.set((Math.random() - 0.5) * 2.5, 0.5 + Math.random() * 1.0, (Math.random() - 0.5) * 2.5);
                    group.add(noise);
                }

                // SYSTEMAUSFALL text representation (binary)
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                for (let i = 0; i < 5; i++) {
                    const digitGeometry = new THREE.BoxGeometry(0.15, 0.25, 0.02);
                    const digit = new THREE.Mesh(digitGeometry, textMaterial);
                    digit.position.set(-0.5 + i * 0.25, 1.5, 0);
                    group.add(digit);
                }

                return group;
            },

            // ========== RUINS ENVIRONMENT ==========

            'broken-column': function() {
                const group = new THREE.Group();
                const stoneColor = 0x9a9080;
                const stoneDark = 0x7a7060;

                // Column base
                const baseGeometry = new THREE.CylinderGeometry(0.6, 0.7, 0.3, 12);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: stoneDark });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.15;
                group.add(base);

                // Main column shaft (broken at top)
                const columnGeometry = new THREE.CylinderGeometry(0.4, 0.45, 2.5, 12);
                const columnMaterial = new THREE.MeshLambertMaterial({ color: stoneColor });
                const column = new THREE.Mesh(columnGeometry, columnMaterial);
                column.position.y = 1.55;
                group.add(column);

                // Broken top with jagged edge
                for (let i = 0; i < 5; i++) {
                    const fragmentGeometry = new THREE.BoxGeometry(0.2 + Math.random() * 0.2, 0.3 + Math.random() * 0.3, 0.2 + Math.random() * 0.2);
                    const fragment = new THREE.Mesh(fragmentGeometry, columnMaterial);
                    const angle = (i / 5) * Math.PI * 2;
                    fragment.position.set(
                        Math.cos(angle) * 0.25,
                        2.8 + Math.random() * 0.3,
                        Math.sin(angle) * 0.25
                    );
                    fragment.rotation.set(Math.random() * 0.3, Math.random(), Math.random() * 0.3);
                    group.add(fragment);
                }

                // Fallen fragment on ground
                const fallenGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.8, 12);
                const fallen = new THREE.Mesh(fallenGeometry, columnMaterial);
                fallen.position.set(0.8, 0.3, 0.5);
                fallen.rotation.z = Math.PI / 2;
                fallen.rotation.y = 0.3;
                group.add(fallen);

                return group;
            },

            'stone-arch': function() {
                const group = new THREE.Group();
                const stoneColor = 0xa09080;

                // Left pillar
                const pillarGeometry = new THREE.BoxGeometry(0.5, 3, 0.5);
                const pillarMaterial = new THREE.MeshLambertMaterial({ color: stoneColor });
                const leftPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                leftPillar.position.set(-1.2, 1.5, 0);
                group.add(leftPillar);

                // Right pillar
                const rightPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                rightPillar.position.set(1.2, 1.5, 0);
                group.add(rightPillar);

                // Arch
                const archGeometry = new THREE.TorusGeometry(1.2, 0.25, 8, 16, Math.PI);
                const arch = new THREE.Mesh(archGeometry, pillarMaterial);
                arch.position.y = 3;
                arch.rotation.x = Math.PI / 2;
                arch.rotation.z = Math.PI / 2;
                group.add(arch);

                // Keystone
                const keystoneGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.5);
                const keystone = new THREE.Mesh(keystoneGeometry, new THREE.MeshLambertMaterial({ color: 0x908070 }));
                keystone.position.set(0, 4.2, 0);
                group.add(keystone);

                // Cracks and weathering
                const crackMaterial = new THREE.MeshLambertMaterial({ color: 0x706050 });
                for (let i = 0; i < 3; i++) {
                    const crackGeometry = new THREE.BoxGeometry(0.05, 0.3 + Math.random() * 0.4, 0.1);
                    const crack = new THREE.Mesh(crackGeometry, crackMaterial);
                    crack.position.set(-1.2 + Math.random() * 2.4, 1 + Math.random() * 2, 0.26);
                    group.add(crack);
                }

                return group;
            },

            'rubble': function() {
                const group = new THREE.Group();
                const stoneColors = [0x8a7a6a, 0x9a8a7a, 0x7a6a5a, 0xa09080];

                // Various rubble pieces
                for (let i = 0; i < 12; i++) {
                    const size = 0.2 + Math.random() * 0.4;
                    const rubbleGeometry = new THREE.DodecahedronGeometry(size, 0);
                    const rubbleMaterial = new THREE.MeshLambertMaterial({
                        color: stoneColors[Math.floor(Math.random() * stoneColors.length)]
                    });
                    const rubble = new THREE.Mesh(rubbleGeometry, rubbleMaterial);
                    rubble.position.set(
                        (Math.random() - 0.5) * 2,
                        size * 0.5,
                        (Math.random() - 0.5) * 2
                    );
                    rubble.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    group.add(rubble);
                }

                // Some larger blocks
                for (let i = 0; i < 3; i++) {
                    const blockGeometry = new THREE.BoxGeometry(0.5 + Math.random() * 0.3, 0.3 + Math.random() * 0.2, 0.4 + Math.random() * 0.2);
                    const blockMaterial = new THREE.MeshLambertMaterial({ color: 0x9a8a7a });
                    const block = new THREE.Mesh(blockGeometry, blockMaterial);
                    block.position.set(
                        (Math.random() - 0.5) * 1.5,
                        0.2,
                        (Math.random() - 0.5) * 1.5
                    );
                    block.rotation.y = Math.random() * Math.PI;
                    group.add(block);
                }

                return group;
            },

            'knight-statue': function() {
                const group = new THREE.Group();
                const stoneColor = 0x7a7a7a;

                // Pedestal
                const pedestalGeometry = new THREE.BoxGeometry(1.2, 0.6, 1.2);
                const pedestalMaterial = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
                const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
                pedestal.position.y = 0.3;
                group.add(pedestal);

                // Body armor
                const bodyGeometry = new THREE.BoxGeometry(0.7, 1.2, 0.5);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: stoneColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                group.add(body);

                // Helmet
                const helmetGeometry = new THREE.SphereGeometry(0.35, 12, 12);
                const helmet = new THREE.Mesh(helmetGeometry, bodyMaterial);
                helmet.position.y = 2.4;
                group.add(helmet);

                // Visor
                const visorGeometry = new THREE.BoxGeometry(0.25, 0.12, 0.1);
                const visorMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
                const visor = new THREE.Mesh(visorGeometry, visorMaterial);
                visor.position.set(0, 2.35, 0.32);
                group.add(visor);

                // Shield
                const shieldGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.1);
                const shield = new THREE.Mesh(shieldGeometry, bodyMaterial);
                shield.position.set(-0.55, 1.3, 0.15);
                shield.rotation.y = 0.3;
                group.add(shield);

                // Sword
                const swordGeometry = new THREE.BoxGeometry(0.08, 1.2, 0.03);
                const sword = new THREE.Mesh(swordGeometry, new THREE.MeshLambertMaterial({ color: 0x8a8a8a }));
                sword.position.set(0.5, 1.5, 0.15);
                group.add(sword);

                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.6, 8);
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(-0.5, 1.35, 0);
                leftArm.rotation.z = 0.3;
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(0.5, 1.35, 0);
                rightArm.rotation.z = -0.3;
                group.add(rightArm);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.8, 8);
                const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                leftLeg.position.set(-0.2, 0.7, 0);
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                rightLeg.position.set(0.2, 0.7, 0);
                group.add(rightLeg);

                return group;
            },

            'ancient-fountain': function() {
                const group = new THREE.Group();
                const stoneColor = 0x8a8a7a;

                // Base pool
                const poolGeometry = new THREE.CylinderGeometry(1.5, 1.6, 0.4, 16);
                const poolMaterial = new THREE.MeshLambertMaterial({ color: stoneColor });
                const pool = new THREE.Mesh(poolGeometry, poolMaterial);
                pool.position.y = 0.2;
                group.add(pool);

                // Inner basin (water area)
                const basinGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.3, 16);
                const basinMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2a4a5a,
                    shininess: 80,
                    transparent: true,
                    opacity: 0.7
                });
                const basin = new THREE.Mesh(basinGeometry, basinMaterial);
                basin.position.y = 0.25;
                group.add(basin);

                // Central pillar
                const pillarGeometry = new THREE.CylinderGeometry(0.25, 0.3, 2.0, 12);
                const pillar = new THREE.Mesh(pillarGeometry, poolMaterial);
                pillar.position.y = 1.2;
                group.add(pillar);

                // Top basin
                const topBasinGeometry = new THREE.CylinderGeometry(0.6, 0.7, 0.3, 12);
                const topBasin = new THREE.Mesh(topBasinGeometry, poolMaterial);
                topBasin.position.y = 2.35;
                group.add(topBasin);

                // Decorative top
                const topGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                const top = new THREE.Mesh(topGeometry, poolMaterial);
                top.position.y = 2.7;
                group.add(top);

                // Cracks and moss patches
                const mossMaterial = new THREE.MeshLambertMaterial({ color: 0x3a5a3a });
                for (let i = 0; i < 4; i++) {
                    const mossGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 6, 6);
                    const moss = new THREE.Mesh(mossGeometry, mossMaterial);
                    const angle = (i / 4) * Math.PI * 2;
                    moss.position.set(
                        Math.cos(angle) * 1.4,
                        0.3,
                        Math.sin(angle) * 1.4
                    );
                    moss.scale.y = 0.5;
                    group.add(moss);
                }

                return group;
            },

            // ========== LEVEL 10 MOBS (Enchanted Grove) ==========

            'pixie': function() {
                const group = new THREE.Group();
                const skinColor = 0xFFE4E1;  // Misty rose
                const wingColor = 0x98FB98;  // Pale green
                const hairColor = 0xFF69B4;  // Hot pink

                // Tiny body (cylinder + spheres for capsule shape)
                const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.3, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.2;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.18, 12, 12);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.65;
                group.add(head);

                // Spiky hair
                for (let i = 0; i < 6; i++) {
                    const hairGeometry = new THREE.ConeGeometry(0.05, 0.2, 4);
                    const hairMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
                    const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    hair.position.set(Math.cos(angle) * 0.1, 1.85, Math.sin(angle) * 0.1);
                    hair.rotation.z = Math.cos(angle) * 0.4;
                    hair.rotation.x = Math.sin(angle) * 0.4;
                    group.add(hair);
                }

                // Big eyes
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x9932CC });
                [-0.07, 0.07].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.68, 0.15);
                    group.add(eye);
                });

                // Delicate wings (4 wings)
                const wingGeometry = new THREE.PlaneGeometry(0.4, 0.6);
                const wingMaterial = new THREE.MeshBasicMaterial({ 
                    color: wingColor, 
                    transparent: true, 
                    opacity: 0.5, 
                    side: THREE.DoubleSide 
                });
                [[-0.25, 0.3], [0.25, -0.3], [-0.2, 0.5], [0.2, -0.5]].forEach(([x, rotY], i) => {
                    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                    wing.position.set(x, 1.3, -0.1);
                    wing.rotation.y = rotY;
                    wing.scale.set(i < 2 ? 1 : 0.7, i < 2 ? 1 : 0.7, 1);
                    group.add(wing);
                });

                // Sparkle particles
                for (let i = 0; i < 8; i++) {
                    const sparkleGeometry = new THREE.SphereGeometry(0.03, 6, 6);
                    const sparkleMaterial = new THREE.MeshBasicMaterial({ color: [0xFFD700, 0xFFFFFF, 0xFF69B4][i % 3] });
                    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                    sparkle.position.set(
                        (Math.random() - 0.5) * 0.8,
                        1.0 + Math.random() * 0.8,
                        (Math.random() - 0.5) * 0.6
                    );
                    group.add(sparkle);
                }

                return group;
            },

            'dark-fairy': function() {
                const group = new THREE.Group();
                const skinColor = 0x8B7D9B;   // Purple-grey skin
                const wingColor = 0x4B0082;   // Indigo wings
                const glowColor = 0xFF00FF;   // Magenta glow

                // Elegant body (cylinder shape)
                const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.8, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.0;
                group.add(body);

                // Dress/robe bottom
                const dressGeometry = new THREE.ConeGeometry(0.4, 0.8, 8);
                const dressMaterial = new THREE.MeshLambertMaterial({ color: 0x2E0854 });
                const dress = new THREE.Mesh(dressGeometry, dressMaterial);
                dress.position.y = 0.6;
                dress.rotation.x = Math.PI;
                group.add(dress);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.6;
                group.add(head);

                // Glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: glowColor });
                [-0.1, 0.1].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.65, 0.2);
                    group.add(eye);
                });

                // Dark crown/tiara
                for (let i = 0; i < 5; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.03, 0.15 + (i === 2 ? 0.1 : 0), 4);
                    const spikeMaterial = new THREE.MeshLambertMaterial({ color: 0x1A1A2E });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    const angle = ((i - 2) / 5) * Math.PI * 0.6;
                    spike.position.set(Math.sin(angle) * 0.2, 1.85, Math.cos(angle) * 0.1);
                    group.add(spike);
                }

                // Large dark wings
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0);
                wingShape.quadraticCurveTo(0.6, 0.3, 0.8, 0.8);
                wingShape.quadraticCurveTo(0.5, 0.6, 0.3, 0.9);
                wingShape.quadraticCurveTo(0, 0.5, 0, 0);
                
                const wingGeometry = new THREE.ShapeGeometry(wingShape);
                const wingMaterial = new THREE.MeshBasicMaterial({ 
                    color: wingColor, 
                    transparent: true, 
                    opacity: 0.7, 
                    side: THREE.DoubleSide 
                });
                
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.1, 1.0, -0.1);
                leftWing.rotation.y = -0.5;
                group.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.1, 1.0, -0.1);
                rightWing.rotation.y = 0.5;
                rightWing.scale.x = -1;
                group.add(rightWing);

                // Magic orb in hand
                const orbGeometry = new THREE.SphereGeometry(0.12, 12, 12);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: glowColor, transparent: true, opacity: 0.8 });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.set(0.4, 1.0, 0.3);
                group.add(orb);

                return group;
            },

            'treant': function() {
                const group = new THREE.Group();
                const barkColor = 0x4A3728;
                const mossColor = 0x3A5F0B;
                const eyeColor = 0x90EE90;

                // Thick trunk body
                const bodyGeometry = new THREE.CylinderGeometry(0.8, 1.0, 2.5, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: barkColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                group.add(body);

                // Bark texture ridges
                for (let i = 0; i < 8; i++) {
                    const ridgeGeometry = new THREE.BoxGeometry(0.15, 2.0, 0.1);
                    const ridge = new THREE.Mesh(ridgeGeometry, bodyMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    ridge.position.set(Math.cos(angle) * 0.85, 1.5, Math.sin(angle) * 0.85);
                    ridge.rotation.y = -angle;
                    group.add(ridge);
                }

                // Head (wider top of trunk)
                const headGeometry = new THREE.CylinderGeometry(0.9, 0.8, 0.8, 8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 3.1;
                group.add(head);

                // Glowing eyes (in bark grooves)
                const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeColor });
                [-0.35, 0.35].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 3.1, 0.75);
                    group.add(eye);
                });

                // Branch arms
                const armGeometry = new THREE.CylinderGeometry(0.15, 0.25, 1.5, 6);
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(-1.2, 2.5, 0);
                leftArm.rotation.z = 0.8;
                group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(1.2, 2.5, 0);
                rightArm.rotation.z = -0.8;
                group.add(rightArm);

                // Leaf crown
                const leafMaterial = new THREE.MeshLambertMaterial({ color: mossColor });
                for (let i = 0; i < 10; i++) {
                    const leafGeometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.15, 6, 6);
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    const angle = (i / 10) * Math.PI * 2;
                    leaf.position.set(
                        Math.cos(angle) * (0.6 + Math.random() * 0.3),
                        3.5 + Math.random() * 0.3,
                        Math.sin(angle) * (0.6 + Math.random() * 0.3)
                    );
                    group.add(leaf);
                }

                // Moss patches on body
                for (let i = 0; i < 5; i++) {
                    const mossGeometry = new THREE.SphereGeometry(0.15, 6, 6);
                    const moss = new THREE.Mesh(mossGeometry, leafMaterial);
                    const angle = Math.random() * Math.PI * 2;
                    moss.position.set(
                        Math.cos(angle) * 0.9,
                        1.0 + Math.random() * 1.5,
                        Math.sin(angle) * 0.9
                    );
                    moss.scale.y = 0.5;
                    group.add(moss);
                }

                // Root feet
                for (let i = 0; i < 4; i++) {
                    const rootGeometry = new THREE.CylinderGeometry(0.1, 0.2, 0.6, 6);
                    const root = new THREE.Mesh(rootGeometry, bodyMaterial);
                    const angle = (i / 4) * Math.PI * 2 + 0.4;
                    root.position.set(Math.cos(angle) * 0.7, 0.2, Math.sin(angle) * 0.7);
                    root.rotation.z = Math.cos(angle) * 0.4;
                    root.rotation.x = Math.sin(angle) * 0.4;
                    group.add(root);
                }

                return group;
            },

            'enchantress': function() {
                const group = new THREE.Group();
                const robeColor = 0x9370DB;   // Medium purple
                const skinColor = 0xFFDBFF;   // Light pink
                const hairColor = 0xE6E6FA;   // Lavender
                const magicColor = 0x00FFAA;  // Spring green

                // Flowing robe body
                const robeGeometry = new THREE.ConeGeometry(0.6, 2.0, 8);
                const robeMaterial = new THREE.MeshLambertMaterial({ color: robeColor });
                const robe = new THREE.Mesh(robeGeometry, robeMaterial);
                robe.position.y = 1.0;
                robe.rotation.x = Math.PI;
                group.add(robe);

                // Upper body (cylinder shape)
                const torsoGeometry = new THREE.CylinderGeometry(0.2, 0.25, 0.5, 8);
                const torsoMaterial = new THREE.MeshLambertMaterial({ color: robeColor });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.8;
                group.add(torso);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.28, 12, 12);
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.4;
                group.add(head);

                // Flowing hair
                const hairMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
                for (let i = 0; i < 8; i++) {
                    const strandGeometry = new THREE.CylinderGeometry(0.04, 0.02, 0.6 + Math.random() * 0.3, 6);
                    const strand = new THREE.Mesh(strandGeometry, hairMaterial);
                    const angle = ((i / 8) * Math.PI) + Math.PI * 0.5;
                    strand.position.set(
                        Math.cos(angle) * 0.2,
                        2.3,
                        Math.sin(angle) * 0.2 - 0.1
                    );
                    strand.rotation.x = 0.3;
                    strand.rotation.z = Math.cos(angle) * 0.3;
                    group.add(strand);
                }

                // Pretty eyes
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x9932CC });
                [-0.1, 0.1].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 2.45, 0.23);
                    group.add(eye);
                });

                // Wizard staff
                const staffGeometry = new THREE.CylinderGeometry(0.04, 0.05, 2.5, 8);
                const staffMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                staff.position.set(0.6, 1.2, 0.2);
                staff.rotation.z = -0.2;
                group.add(staff);

                // Staff crystal top
                const crystalGeometry = new THREE.OctahedronGeometry(0.15, 0);
                const crystalMaterial = new THREE.MeshBasicMaterial({ color: magicColor, transparent: true, opacity: 0.8 });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(0.5, 2.5, 0.15);
                group.add(crystal);

                // Floating magic particles
                for (let i = 0; i < 6; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.04, 6, 6);
                    const particleMaterial = new THREE.MeshBasicMaterial({ color: [magicColor, 0xFF69B4, 0xFFD700][i % 3] });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.set(
                        0.5 + (Math.random() - 0.5) * 0.5,
                        2.3 + Math.random() * 0.5,
                        0.15 + (Math.random() - 0.5) * 0.3
                    );
                    group.add(particle);
                }

                return group;
            },

            'giant-butterfly': function() {
                const group = new THREE.Group();
                const bodyColor = 0x8B4513;
                const wingColors = [0xFF69B4, 0x9370DB, 0x00CED1, 0xFFD700];

                // Fuzzy body (cylinder shape)
                const bodyGeometry = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                body.rotation.x = Math.PI / 6;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.set(0, 2.1, 0.15);
                group.add(head);

                // Compound eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 2.15, 0.3);
                    group.add(eye);
                });

                // Curly antennae
                const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 6);
                const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                [-0.1, 0.1].forEach((x, i) => {
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.set(x, 2.4, 0.1);
                    antenna.rotation.z = x * 2;
                    group.add(antenna);
                    
                    // Antenna tip
                    const tipGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                    const tip = new THREE.Mesh(tipGeometry, antennaMaterial);
                    tip.position.set(x * 2.5, 2.6, 0.1);
                    group.add(tip);
                });

                // Large ornate wings
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0);
                wingShape.quadraticCurveTo(1.2, 0.8, 1.0, 1.5);
                wingShape.quadraticCurveTo(0.5, 1.8, 0, 1.3);
                wingShape.quadraticCurveTo(-0.3, 0.6, 0, 0);

                const wingGeometry = new THREE.ShapeGeometry(wingShape);
                
                // Create 4 wings with different colors
                [[-0.15, 0.8, 0xFF69B4], [0.15, -0.8, 0x9370DB]].forEach(([x, rotY, color]) => {
                    const wingMaterial = new THREE.MeshBasicMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.7, 
                        side: THREE.DoubleSide 
                    });
                    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                    wing.position.set(x, 1.3, -0.1);
                    wing.rotation.y = rotY;
                    group.add(wing);
                });

                // Lower wings (smaller)
                const lowerWingShape = new THREE.Shape();
                lowerWingShape.ellipse(0, 0, 0.6, 0.4, 0, Math.PI * 2);
                const lowerWingGeometry = new THREE.ShapeGeometry(lowerWingShape);
                
                [[-0.2, 0.6, 0x00CED1], [0.2, -0.6, 0xFFD700]].forEach(([x, rotY, color]) => {
                    const wingMaterial = new THREE.MeshBasicMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.6, 
                        side: THREE.DoubleSide 
                    });
                    const wing = new THREE.Mesh(lowerWingGeometry, wingMaterial);
                    wing.position.set(x, 1.0, -0.15);
                    wing.rotation.y = rotY;
                    group.add(wing);
                });

                // Wing patterns (spots)
                const spotGeometry = new THREE.CircleGeometry(0.1, 8);
                const spotMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
                [[0.5, 1.8, -0.05], [-0.5, 1.8, -0.05], [0.3, 1.3, -0.05], [-0.3, 1.3, -0.05]].forEach(pos => {
                    const spot = new THREE.Mesh(spotGeometry, spotMaterial);
                    spot.position.set(...pos);
                    group.add(spot);
                });

                // Pollen dust trail
                for (let i = 0; i < 5; i++) {
                    const pollenGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                    const pollenMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.6 });
                    const pollen = new THREE.Mesh(pollenGeometry, pollenMaterial);
                    pollen.position.set(
                        (Math.random() - 0.5) * 0.4,
                        0.8 - i * 0.15,
                        -0.2 - i * 0.1
                    );
                    group.add(pollen);
                }

                return group;
            },

            'corrupted-unicorn': function() {
                const group = new THREE.Group();
                const bodyColor = 0x1A1A2E;      // Dark purple-black
                const maneColor = 0x9400D3;     // Dark violet
                const hornColor = 0x4B0082;     // Indigo
                const glowColor = 0xFF00FF;     // Magenta
                const eyeColor = 0xFF0000;      // Red

                // Horse body (flying pose)
                const bodyGeometry = new THREE.CylinderGeometry(0.8, 1.0, 3.5, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                body.position.set(0, 2.0, 0);
                group.add(body);

                // Neck
                const neckGeometry = new THREE.CylinderGeometry(0.5, 0.7, 1.5, 8);
                const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
                neck.position.set(1.8, 2.8, 0);
                neck.rotation.z = -0.8;
                group.add(neck);

                // Head
                const headGeometry = new THREE.CylinderGeometry(0.3, 0.5, 1.2, 8);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.set(2.5, 3.5, 0);
                head.rotation.z = -1.2;
                group.add(head);

                // Snout
                const snoutGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.6, 8);
                const snout = new THREE.Mesh(snoutGeometry, bodyMaterial);
                snout.position.set(3.0, 3.7, 0);
                snout.rotation.z = -1.4;
                group.add(snout);

                // Corrupted horn (twisted)
                const hornGeometry = new THREE.ConeGeometry(0.15, 1.2, 8);
                const hornMaterial = new THREE.MeshLambertMaterial({ color: hornColor });
                const horn = new THREE.Mesh(hornGeometry, hornMaterial);
                horn.position.set(2.3, 4.2, 0);
                horn.rotation.z = -0.3;
                group.add(horn);

                // Horn glow
                const hornGlowGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const hornGlowMaterial = new THREE.MeshBasicMaterial({ color: glowColor, transparent: true, opacity: 0.6 });
                const hornGlow = new THREE.Mesh(hornGlowGeometry, hornGlowMaterial);
                hornGlow.position.set(2.2, 4.7, 0);
                group.add(hornGlow);

                // Glowing red eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeColor });
                const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye1.position.set(2.7, 3.7, 0.35);
                group.add(eye1);
                const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye2.position.set(2.7, 3.7, -0.35);
                group.add(eye2);

                // Flowing dark mane
                const maneMaterial = new THREE.MeshLambertMaterial({ color: maneColor });
                for (let i = 0; i < 12; i++) {
                    const strandGeometry = new THREE.CylinderGeometry(0.05, 0.02, 0.8 + Math.random() * 0.5, 6);
                    const strand = new THREE.Mesh(strandGeometry, maneMaterial);
                    strand.position.set(
                        1.5 + i * 0.1,
                        2.8 + Math.sin(i * 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.3
                    );
                    strand.rotation.z = 1.5 + Math.random() * 0.5;
                    strand.rotation.x = (Math.random() - 0.5) * 0.3;
                    group.add(strand);
                }

                // Dark feathered wings (spread for flight)
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0);
                wingShape.lineTo(2.5, 0.5);
                wingShape.lineTo(3.0, 0);
                wingShape.lineTo(2.8, -0.3);
                wingShape.lineTo(2.0, -0.5);
                wingShape.lineTo(1.2, -0.3);
                wingShape.lineTo(0, 0);

                const wingGeometry = new THREE.ShapeGeometry(wingShape);
                const wingMaterial = new THREE.MeshLambertMaterial({ color: 0x2E0854, side: THREE.DoubleSide });

                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(0, 2.5, 0.8);
                leftWing.rotation.x = -0.3;
                leftWing.rotation.y = -0.5;
                group.add(leftWing);

                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0, 2.5, -0.8);
                rightWing.rotation.x = 0.3;
                rightWing.rotation.y = 0.5;
                rightWing.scale.z = -1;
                group.add(rightWing);

                // Legs (tucked for flying)
                const legGeometry = new THREE.CylinderGeometry(0.12, 0.1, 1.0, 6);
                [[0.8, 1.2, 0.4], [0.8, 1.2, -0.4], [-0.8, 1.2, 0.4], [-0.8, 1.2, -0.4]].forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leg.position.set(...pos);
                    leg.rotation.x = pos[2] > 0 ? 0.5 : -0.5;
                    leg.rotation.z = pos[0] > 0 ? -0.3 : 0.3;
                    group.add(leg);
                });

                // Flowing tail
                for (let i = 0; i < 8; i++) {
                    const tailGeometry = new THREE.CylinderGeometry(0.04, 0.02, 1.0 + Math.random() * 0.5, 6);
                    const tail = new THREE.Mesh(tailGeometry, maneMaterial);
                    tail.position.set(-2.0, 1.8 - i * 0.05, (Math.random() - 0.5) * 0.4);
                    tail.rotation.z = 1.8 + Math.random() * 0.4;
                    group.add(tail);
                }

                // Dark aura particles
                for (let i = 0; i < 10; i++) {
                    const auraGeometry = new THREE.SphereGeometry(0.08 + Math.random() * 0.05, 6, 6);
                    const auraMaterial = new THREE.MeshBasicMaterial({ 
                        color: [glowColor, 0x4B0082, 0x9400D3][i % 3], 
                        transparent: true, 
                        opacity: 0.5 
                    });
                    const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                    aura.position.set(
                        (Math.random() - 0.5) * 4,
                        1.5 + Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    );
                    group.add(aura);
                }

                return group;
            },

            // ========== LEVEL 10 ENVIRONMENT ==========

            'giant-tree': function() {
                const group = new THREE.Group();
                const trunkColor = 0x4A3728;
                const leafColor = 0x228B22;
                const glowColor = 0x98FB98;

                // Massive trunk
                const trunkGeometry = new THREE.CylinderGeometry(1.2, 1.8, 5.0, 12);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: trunkColor });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2.5;
                group.add(trunk);

                // Bark detail
                for (let i = 0; i < 10; i++) {
                    const barkGeometry = new THREE.BoxGeometry(0.2, 1.5 + Math.random(), 0.1);
                    const bark = new THREE.Mesh(barkGeometry, trunkMaterial);
                    const angle = (i / 10) * Math.PI * 2;
                    bark.position.set(Math.cos(angle) * 1.3, 2 + Math.random() * 2, Math.sin(angle) * 1.3);
                    bark.rotation.y = -angle;
                    group.add(bark);
                }

                // Large root system
                for (let i = 0; i < 6; i++) {
                    const rootGeometry = new THREE.CylinderGeometry(0.2, 0.4, 2.0, 6);
                    const root = new THREE.Mesh(rootGeometry, trunkMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    root.position.set(Math.cos(angle) * 1.5, 0.5, Math.sin(angle) * 1.5);
                    root.rotation.z = Math.cos(angle) * 0.6;
                    root.rotation.x = Math.sin(angle) * 0.6;
                    group.add(root);
                }

                // Lush canopy
                const leafMaterial = new THREE.MeshLambertMaterial({ color: leafColor });
                for (let i = 0; i < 20; i++) {
                    const leafGeometry = new THREE.SphereGeometry(0.8 + Math.random() * 0.6, 8, 8);
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 2.5;
                    leaf.position.set(
                        Math.cos(angle) * radius,
                        5.0 + Math.random() * 2,
                        Math.sin(angle) * radius
                    );
                    group.add(leaf);
                }

                // Glowing fairy lights in canopy
                for (let i = 0; i < 8; i++) {
                    const lightGeometry = new THREE.SphereGeometry(0.08, 6, 6);
                    const lightMaterial = new THREE.MeshBasicMaterial({ 
                        color: [0xFFD700, glowColor, 0xFF69B4][i % 3] 
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    const angle = Math.random() * Math.PI * 2;
                    light.position.set(
                        Math.cos(angle) * (1 + Math.random()),
                        4.5 + Math.random() * 2,
                        Math.sin(angle) * (1 + Math.random())
                    );
                    group.add(light);
                }

                return group;
            },

            'fairy-ring': function() {
                const group = new THREE.Group();
                const mushroomColor = 0xFF6B6B;
                const spotColor = 0xFFFFFF;

                // Ring of small mushrooms
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const radius = 1.5;

                    // Mushroom cap
                    const capGeometry = new THREE.SphereGeometry(0.15, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const capMaterial = new THREE.MeshLambertMaterial({ color: mushroomColor });
                    const cap = new THREE.Mesh(capGeometry, capMaterial);
                    cap.position.set(Math.cos(angle) * radius, 0.25, Math.sin(angle) * radius);
                    cap.rotation.x = Math.PI;
                    group.add(cap);

                    // Stem
                    const stemGeometry = new THREE.CylinderGeometry(0.04, 0.06, 0.2, 6);
                    const stemMaterial = new THREE.MeshLambertMaterial({ color: 0xFFF8DC });
                    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                    stem.position.set(Math.cos(angle) * radius, 0.1, Math.sin(angle) * radius);
                    group.add(stem);

                    // White spots
                    for (let j = 0; j < 3; j++) {
                        const spotGeometry = new THREE.SphereGeometry(0.03, 6, 6);
                        const spotMaterial = new THREE.MeshBasicMaterial({ color: spotColor });
                        const spot = new THREE.Mesh(spotGeometry, spotMaterial);
                        const spotAngle = (j / 3) * Math.PI * 2;
                        spot.position.set(
                            Math.cos(angle) * radius + Math.cos(spotAngle) * 0.08,
                            0.28,
                            Math.sin(angle) * radius + Math.sin(spotAngle) * 0.08
                        );
                        group.add(spot);
                    }
                }

                // Glowing center
                const glowGeometry = new THREE.CircleGeometry(1.0, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x98FB98, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 0.02;
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);

                // Sparkles floating in center
                for (let i = 0; i < 6; i++) {
                    const sparkleGeometry = new THREE.SphereGeometry(0.04, 6, 6);
                    const sparkleMaterial = new THREE.MeshBasicMaterial({ 
                        color: [0xFFD700, 0xFFFFFF, 0xFF69B4][i % 3] 
                    });
                    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                    const angle = Math.random() * Math.PI * 2;
                    sparkle.position.set(
                        Math.cos(angle) * Math.random() * 0.8,
                        0.3 + Math.random() * 0.5,
                        Math.sin(angle) * Math.random() * 0.8
                    );
                    group.add(sparkle);
                }

                return group;
            },

            'enchanted-mushroom': function() {
                const group = new THREE.Group();
                const capColor = 0xFF1493;    // Deep pink
                const stemColor = 0xFFF8DC;   // Cornsilk
                const glowColor = 0x00FFAA;

                // Large stem
                const stemGeometry = new THREE.CylinderGeometry(0.3, 0.5, 1.5, 8);
                const stemMaterial = new THREE.MeshLambertMaterial({ color: stemColor });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.y = 0.75;
                group.add(stem);

                // Big dome cap
                const capGeometry = new THREE.SphereGeometry(1.0, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                const capMaterial = new THREE.MeshLambertMaterial({ color: capColor });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.y = 1.5;
                cap.rotation.x = Math.PI;
                group.add(cap);

                // White spots on cap
                for (let i = 0; i < 8; i++) {
                    const spotGeometry = new THREE.SphereGeometry(0.12 + Math.random() * 0.08, 8, 8);
                    const spotMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                    const spot = new THREE.Mesh(spotGeometry, spotMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    const r = 0.5 + Math.random() * 0.3;
                    spot.position.set(
                        Math.cos(angle) * r,
                        1.7 + Math.random() * 0.2,
                        Math.sin(angle) * r
                    );
                    spot.scale.y = 0.3;
                    group.add(spot);
                }

                // Glow underneath cap
                const glowGeometry = new THREE.CircleGeometry(0.8, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: glowColor, 
                    transparent: true, 
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 1.4;
                glow.rotation.x = Math.PI / 2;
                group.add(glow);

                return group;
            },

            'crystal-flower': function() {
                const group = new THREE.Group();
                const stemColor = 0x228B22;
                const petalColors = [0xFF69B4, 0x9370DB, 0x00CED1, 0xFFD700];

                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.05, 0.08, 1.0, 6);
                const stemMaterial = new THREE.MeshLambertMaterial({ color: stemColor });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.y = 0.5;
                group.add(stem);

                // Crystal petals (octahedron shapes)
                for (let i = 0; i < 6; i++) {
                    const petalGeometry = new THREE.OctahedronGeometry(0.2, 0);
                    const petalMaterial = new THREE.MeshBasicMaterial({ 
                        color: petalColors[i % petalColors.length],
                        transparent: true,
                        opacity: 0.7
                    });
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    petal.position.set(
                        Math.cos(angle) * 0.25,
                        1.1,
                        Math.sin(angle) * 0.25
                    );
                    petal.rotation.z = Math.PI / 4;
                    petal.scale.set(0.5, 1.5, 0.5);
                    group.add(petal);
                }

                // Center gem
                const centerGeometry = new THREE.IcosahedronGeometry(0.15, 0);
                const centerMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.position.y = 1.15;
                group.add(center);

                // Leaves
                const leafGeometry = new THREE.PlaneGeometry(0.3, 0.5);
                const leafMaterial = new THREE.MeshLambertMaterial({ 
                    color: stemColor, 
                    side: THREE.DoubleSide 
                });
                [-0.15, 0.15].forEach((x, i) => {
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    leaf.position.set(x, 0.4, 0);
                    leaf.rotation.y = i === 0 ? 0.5 : -0.5;
                    leaf.rotation.z = i === 0 ? 0.3 : -0.3;
                    group.add(leaf);
                });

                return group;
            },

            'rainbow-arc': function() {
                const group = new THREE.Group();
                const colors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];

                // Rainbow bands
                colors.forEach((color, i) => {
                    const arcGeometry = new THREE.TorusGeometry(2.0 - i * 0.12, 0.08, 8, 32, Math.PI);
                    const arcMaterial = new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.7
                    });
                    const arc = new THREE.Mesh(arcGeometry, arcMaterial);
                    arc.position.y = 0;
                    arc.rotation.x = Math.PI / 2;
                    arc.rotation.z = Math.PI / 2;
                    group.add(arc);
                });

                // Sparkles along rainbow
                for (let i = 0; i < 12; i++) {
                    const sparkleGeometry = new THREE.SphereGeometry(0.06, 6, 6);
                    const sparkleMaterial = new THREE.MeshBasicMaterial({ 
                        color: [0xFFFFFF, 0xFFD700][i % 2] 
                    });
                    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                    const angle = (i / 12) * Math.PI;
                    sparkle.position.set(
                        0,
                        Math.sin(angle) * 1.8,
                        Math.cos(angle) * 1.8
                    );
                    group.add(sparkle);
                }

                return group;
            },

            // ========== LEVEL 10 HAZARDS ==========

            'thorn-patch': function() {
                const group = new THREE.Group();
                const vineColor = 0x228B22;
                const thornColor = 0x4A2810;

                // Base vines
                const vineMaterial = new THREE.MeshLambertMaterial({ color: vineColor });
                for (let i = 0; i < 8; i++) {
                    const vineGeometry = new THREE.CylinderGeometry(0.05, 0.08, 1.5 + Math.random(), 6);
                    const vine = new THREE.Mesh(vineGeometry, vineMaterial);
                    vine.position.set(
                        (Math.random() - 0.5) * 2,
                        0.5,
                        (Math.random() - 0.5) * 2
                    );
                    vine.rotation.z = (Math.random() - 0.5) * 0.8;
                    vine.rotation.x = (Math.random() - 0.5) * 0.8;
                    group.add(vine);
                }

                // Thorns
                const thornMaterial = new THREE.MeshLambertMaterial({ color: thornColor });
                for (let i = 0; i < 20; i++) {
                    const thornGeometry = new THREE.ConeGeometry(0.03, 0.15, 4);
                    const thorn = new THREE.Mesh(thornGeometry, thornMaterial);
                    thorn.position.set(
                        (Math.random() - 0.5) * 2.5,
                        Math.random() * 1.2,
                        (Math.random() - 0.5) * 2.5
                    );
                    thorn.rotation.z = Math.random() * Math.PI;
                    thorn.rotation.x = Math.random() * Math.PI;
                    group.add(thorn);
                }

                // Warning glow
                const glowGeometry = new THREE.CircleGeometry(1.3, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF4444, 
                    transparent: true, 
                    opacity: 0.2 
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 0.02;
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);

                return group;
            },

            'sleep-spore': function() {
                const group = new THREE.Group();
                const cloudColor = 0xE6E6FA;   // Lavender
                const sporeColor = 0xDDA0DD;   // Plum

                // Spore cloud base
                for (let i = 0; i < 6; i++) {
                    const cloudGeometry = new THREE.SphereGeometry(0.4 + Math.random() * 0.3, 8, 8);
                    const cloudMaterial = new THREE.MeshBasicMaterial({ 
                        color: cloudColor, 
                        transparent: true, 
                        opacity: 0.4 
                    });
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloud.position.set(
                        (Math.random() - 0.5) * 1.5,
                        0.5 + Math.random() * 0.5,
                        (Math.random() - 0.5) * 1.5
                    );
                    group.add(cloud);
                }

                // Floating spore particles
                for (let i = 0; i < 15; i++) {
                    const sporeGeometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.03, 6, 6);
                    const sporeMaterial = new THREE.MeshBasicMaterial({ 
                        color: sporeColor,
                        transparent: true,
                        opacity: 0.7
                    });
                    const spore = new THREE.Mesh(sporeGeometry, sporeMaterial);
                    spore.position.set(
                        (Math.random() - 0.5) * 2,
                        0.3 + Math.random() * 1.2,
                        (Math.random() - 0.5) * 2
                    );
                    group.add(spore);
                }

                // Zzz symbols
                const zMaterial = new THREE.MeshBasicMaterial({ color: 0x9370DB });
                [0.8, 1.1, 1.4].forEach((y, i) => {
                    const zGeometry = new THREE.BoxGeometry(0.15 - i * 0.03, 0.04, 0.04);
                    const z = new THREE.Mesh(zGeometry, zMaterial);
                    z.position.set(0.5 + i * 0.15, y, 0);
                    group.add(z);
                });

                return group;
            },

            // ========== LEVEL 10 ITEMS ==========

            'size-potion': function() {
                const group = new THREE.Group();
                const bottleColor = 0xADD8E6;  // Light blue glass
                const liquidColor = 0xFF69B4;  // Hot pink
                const corkColor = 0x8B4513;

                // Bottle body
                const bottleGeometry = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 12);
                const bottleMaterial = new THREE.MeshPhongMaterial({ 
                    color: bottleColor,
                    transparent: true,
                    opacity: 0.6,
                    shininess: 100
                });
                const bottle = new THREE.Mesh(bottleGeometry, bottleMaterial);
                bottle.position.y = 0.5;
                group.add(bottle);

                // Bottle neck
                const neckGeometry = new THREE.CylinderGeometry(0.12, 0.2, 0.3, 12);
                const neck = new THREE.Mesh(neckGeometry, bottleMaterial);
                neck.position.y = 1.0;
                group.add(neck);

                // Cork
                const corkGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.15, 8);
                const corkMaterial = new THREE.MeshLambertMaterial({ color: corkColor });
                const cork = new THREE.Mesh(corkGeometry, corkMaterial);
                cork.position.y = 1.2;
                group.add(cork);

                // Liquid inside
                const liquidGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.6, 12);
                const liquidMaterial = new THREE.MeshBasicMaterial({ 
                    color: liquidColor,
                    transparent: true,
                    opacity: 0.7
                });
                const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
                liquid.position.y = 0.45;
                group.add(liquid);

                // Bubbles in liquid
                for (let i = 0; i < 5; i++) {
                    const bubbleGeometry = new THREE.SphereGeometry(0.04, 6, 6);
                    const bubbleMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFFFFFF,
                        transparent: true,
                        opacity: 0.6
                    });
                    const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                    bubble.position.set(
                        (Math.random() - 0.5) * 0.3,
                        0.3 + Math.random() * 0.4,
                        (Math.random() - 0.5) * 0.3
                    );
                    group.add(bubble);
                }

                // Magical glow
                const glowGeometry = new THREE.SphereGeometry(0.5, 12, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: liquidColor,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 0.6;
                group.add(glow);

                // Size arrows (up and down)
                const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
                // Up arrow
                const upArrowGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
                const upArrow = new THREE.Mesh(upArrowGeometry, arrowMaterial);
                upArrow.position.set(0.5, 0.9, 0);
                group.add(upArrow);
                // Down arrow
                const downArrow = new THREE.Mesh(upArrowGeometry, arrowMaterial);
                downArrow.position.set(0.5, 0.5, 0);
                downArrow.rotation.z = Math.PI;
                group.add(downArrow);

                return group;
            },

            // ========== LEVEL 11 EASTER MOBS ==========

            'bunny': function() {
                const group = new THREE.Group();
                const furColor = 0xFFFFFF;      // White
                const innerEarColor = 0xFFB6C1; // Light pink
                const noseColor = 0xFF69B4;     // Pink
                const eyeColor = 0x000000;      // Black

                // Body
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: furColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.6;
                body.scale.y = 0.8;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.3;
                group.add(head);

                // Ears
                const earGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.6, 8);
                const innerEarMaterial = new THREE.MeshLambertMaterial({ color: innerEarColor });
                [-0.15, 0.15].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeometry, bodyMaterial);
                    ear.position.set(x, 1.8, 0);
                    ear.rotation.z = i === 0 ? 0.2 : -0.2;
                    group.add(ear);
                    // Inner ear
                    const innerEarGeometry = new THREE.CylinderGeometry(0.04, 0.08, 0.4, 8);
                    const innerEar = new THREE.Mesh(innerEarGeometry, innerEarMaterial);
                    innerEar.position.set(x, 1.8, 0.05);
                    innerEar.rotation.z = i === 0 ? 0.2 : -0.2;
                    group.add(innerEar);
                });

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeColor });
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.35, 0.35);
                    group.add(eye);
                });

                // Nose
                const noseGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const noseMaterial = new THREE.MeshLambertMaterial({ color: noseColor });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(0, 1.25, 0.4);
                group.add(nose);

                // Tail (fluffy ball)
                const tailGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.position.set(0, 0.5, -0.5);
                group.add(tail);

                // Feet
                const footGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                [-0.2, 0.2].forEach(x => {
                    const foot = new THREE.Mesh(footGeometry, bodyMaterial);
                    foot.position.set(x, 0.15, 0.2);
                    foot.scale.set(1, 0.5, 1.4);
                    group.add(foot);
                });

                return group;
            },

            'chick': function() {
                const group = new THREE.Group();
                const bodyColor = 0xFFD700;     // Golden yellow
                const beakColor = 0xFF8C00;     // Dark orange
                const eyeColor = 0x000000;
                const wingColor = 0xFFA500;     // Orange

                // Round body
                const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.0;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 2.0;
                group.add(head);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeColor });
                [-0.2, 0.2].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 2.1, 0.4);
                    group.add(eye);
                });

                // Beak
                const beakGeometry = new THREE.ConeGeometry(0.15, 0.3, 8);
                const beakMaterial = new THREE.MeshLambertMaterial({ color: beakColor });
                const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                beak.position.set(0, 1.9, 0.55);
                beak.rotation.x = Math.PI / 2;
                group.add(beak);

                // Small comb on head
                const combGeometry = new THREE.ConeGeometry(0.08, 0.2, 4);
                const combMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4444 });
                for (let i = 0; i < 3; i++) {
                    const comb = new THREE.Mesh(combGeometry, combMaterial);
                    comb.position.set(0, 2.5 + i * 0.05, -0.1 + i * 0.05);
                    group.add(comb);
                }

                // Wings
                const wingGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const wingMaterial = new THREE.MeshLambertMaterial({ color: wingColor });
                [-0.7, 0.7].forEach(x => {
                    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                    wing.position.set(x, 1.2, 0);
                    wing.scale.set(0.4, 0.8, 0.6);
                    group.add(wing);
                });

                // Feet
                const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6);
                const legMaterial = new THREE.MeshLambertMaterial({ color: beakColor });
                [-0.3, 0.3].forEach(x => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 0.15, 0);
                    group.add(leg);
                });

                return group;
            },

            'egg-warrior': function() {
                const group = new THREE.Group();
                const eggColor = 0xFFE4E1;      // Misty rose
                const stripColor1 = 0xFF69B4;   // Hot pink
                const stripColor2 = 0x98FB98;   // Pale green
                const stripColor3 = 0x87CEEB;   // Sky blue

                // Egg body
                const eggGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const eggMaterial = new THREE.MeshLambertMaterial({ color: eggColor });
                const egg = new THREE.Mesh(eggGeometry, eggMaterial);
                egg.position.y = 1.0;
                egg.scale.set(0.8, 1.2, 0.8);
                group.add(egg);

                // Decorative stripes
                [stripColor1, stripColor2, stripColor3].forEach((color, i) => {
                    const stripeGeometry = new THREE.TorusGeometry(0.4, 0.04, 8, 16);
                    const stripeMaterial = new THREE.MeshLambertMaterial({ color });
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.y = 0.7 + i * 0.3;
                    stripe.rotation.x = Math.PI / 2;
                    stripe.scale.set(0.8, 1, 0.8);
                    group.add(stripe);
                });

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.2, 0.4);
                    group.add(eye);
                    // Eye whites
                    const whiteGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const whiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                    const white = new THREE.Mesh(whiteGeometry, whiteMaterial);
                    white.position.set(x, 1.2, 0.38);
                    group.add(white);
                });

                // Little arms
                const armGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.4, 6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: eggColor });
                [-0.5, 0.5].forEach((x, i) => {
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.set(x, 1.0, 0);
                    arm.rotation.z = i === 0 ? 0.8 : -0.8;
                    group.add(arm);
                });

                // Little legs
                const legGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.3, 6);
                [-0.2, 0.2].forEach(x => {
                    const leg = new THREE.Mesh(legGeometry, armMaterial);
                    leg.position.set(x, 0.2, 0);
                    group.add(leg);
                });

                // Bow (weapon)
                const bowGeometry = new THREE.TorusGeometry(0.25, 0.02, 6, 16, Math.PI);
                const bowMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const bow = new THREE.Mesh(bowGeometry, bowMaterial);
                bow.position.set(0.6, 1.0, 0.2);
                bow.rotation.y = Math.PI / 2;
                group.add(bow);

                return group;
            },

            'easter-wizard': function() {
                const group = new THREE.Group();
                const robeColor = 0xE6E6FA;     // Lavender
                const furColor = 0xFFFFFF;      // White
                const staffColor = 0xFFD700;   // Gold
                const gemColor = 0xFFA500;     // Orange (carrot)

                // Body (robe)
                const robeGeometry = new THREE.ConeGeometry(0.5, 1.2, 8);
                const robeMaterial = new THREE.MeshLambertMaterial({ color: robeColor });
                const robe = new THREE.Mesh(robeGeometry, robeMaterial);
                robe.position.y = 0.6;
                group.add(robe);

                // Head (bunny)
                const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: furColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.5;
                group.add(head);

                // Ears
                const earGeometry = new THREE.CylinderGeometry(0.06, 0.1, 0.5, 8);
                const innerEarMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
                [-0.12, 0.12].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeometry, headMaterial);
                    ear.position.set(x, 2.0, 0);
                    ear.rotation.z = i === 0 ? 0.15 : -0.15;
                    group.add(ear);
                });

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                [-0.1, 0.1].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.55, 0.3);
                    group.add(eye);
                });

                // Nose
                const noseGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const noseMaterial = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(0, 1.45, 0.35);
                group.add(nose);

                // Wizard hat
                const hatGeometry = new THREE.ConeGeometry(0.3, 0.6, 8);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: 0x9370DB });
                const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                hat.position.y = 2.1;
                group.add(hat);

                // Hat brim
                const brimGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.05, 16);
                const brim = new THREE.Mesh(brimGeometry, hatMaterial);
                brim.position.y = 1.8;
                group.add(brim);

                // Staff (carrot)
                const staffGeometry = new THREE.CylinderGeometry(0.03, 0.08, 1.2, 8);
                const staffMaterial = new THREE.MeshLambertMaterial({ color: gemColor });
                const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                staff.position.set(0.5, 1.0, 0.2);
                staff.rotation.z = -0.3;
                group.add(staff);

                // Staff top (leaf)
                const leafGeometry = new THREE.ConeGeometry(0.1, 0.2, 6);
                const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.set(0.4, 1.7, 0.15);
                group.add(leaf);

                // Magic sparkles
                for (let i = 0; i < 5; i++) {
                    const sparkleGeometry = new THREE.SphereGeometry(0.04, 6, 6);
                    const sparkleMaterial = new THREE.MeshBasicMaterial({ 
                        color: [0xFFD700, 0xFF69B4, 0x98FB98][i % 3] 
                    });
                    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                    sparkle.position.set(
                        0.3 + Math.random() * 0.4,
                        1.5 + Math.random() * 0.5,
                        0.1 + Math.random() * 0.2
                    );
                    group.add(sparkle);
                }

                return group;
            },

            'egg-bomber': function() {
                const group = new THREE.Group();
                const bodyColor = 0x87CEEB;     // Sky blue
                const wingColor = 0xFFD700;     // Gold
                const beakColor = 0xFF8C00;     // Orange
                const nestColor = 0x8B4513;     // Brown

                // Body
                const bodyGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                body.scale.set(1, 0.8, 0.8);
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.set(0.3, 1.8, 0);
                group.add(head);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye.position.set(0.45, 1.85, 0.15);
                group.add(eye);

                // Beak
                const beakGeometry = new THREE.ConeGeometry(0.08, 0.2, 6);
                const beakMaterial = new THREE.MeshLambertMaterial({ color: beakColor });
                const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                beak.position.set(0.55, 1.75, 0);
                beak.rotation.z = -Math.PI / 2;
                group.add(beak);

                // Wings
                const wingGeometry = new THREE.SphereGeometry(0.35, 8, 8);
                const wingMaterial = new THREE.MeshLambertMaterial({ color: wingColor });
                [-0.4, 0.4].forEach(z => {
                    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                    wing.position.set(-0.1, 1.6, z);
                    wing.scale.set(0.6, 0.3, 1);
                    wing.rotation.x = z > 0 ? -0.5 : 0.5;
                    group.add(wing);
                });

                // Tail feathers
                for (let i = 0; i < 3; i++) {
                    const tailGeometry = new THREE.CylinderGeometry(0.02, 0.05, 0.3, 6);
                    const tailMaterial = new THREE.MeshLambertMaterial({ 
                        color: [0xFF69B4, 0x98FB98, 0x87CEEB][i] 
                    });
                    const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                    tail.position.set(-0.5, 1.4 + i * 0.1, (i - 1) * 0.1);
                    tail.rotation.z = 1.5;
                    group.add(tail);
                }

                // Nest on head
                const nestGeometry = new THREE.TorusGeometry(0.2, 0.08, 6, 12);
                const nestMaterial = new THREE.MeshLambertMaterial({ color: nestColor });
                const nest = new THREE.Mesh(nestGeometry, nestMaterial);
                nest.position.set(0.2, 2.1, 0);
                nest.rotation.x = Math.PI / 2;
                group.add(nest);

                // Eggs in nest
                const eggColors = [0xFF69B4, 0x98FB98, 0xFFD700];
                for (let i = 0; i < 3; i++) {
                    const eggGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                    const eggMaterial = new THREE.MeshLambertMaterial({ color: eggColors[i] });
                    const egg = new THREE.Mesh(eggGeometry, eggMaterial);
                    const angle = (i / 3) * Math.PI * 2;
                    egg.position.set(
                        0.2 + Math.cos(angle) * 0.1,
                        2.15,
                        Math.sin(angle) * 0.1
                    );
                    egg.scale.y = 1.3;
                    group.add(egg);
                }

                return group;
            },

            'giant-easter-bunny': function() {
                const group = new THREE.Group();
                const furColor = 0xFFF0F5;      // Lavender blush
                const innerEarColor = 0xFFB6C1; // Light pink
                const noseColor = 0xFF69B4;     // Hot pink
                const eyeColor = 0x4169E1;      // Royal blue
                const ribbonColor = 0xFF1493;   // Deep pink
                const basketColor = 0xDAA520;   // Goldenrod

                // Large body
                const bodyGeometry = new THREE.SphereGeometry(1.2, 16, 16);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: furColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 2.0;
                body.scale.y = 1.2;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 4.0;
                group.add(head);

                // Long ears
                const earGeometry = new THREE.CylinderGeometry(0.15, 0.25, 1.5, 8);
                const innerEarMaterial = new THREE.MeshLambertMaterial({ color: innerEarColor });
                [-0.4, 0.4].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeometry, bodyMaterial);
                    ear.position.set(x, 5.2, 0);
                    ear.rotation.z = i === 0 ? 0.2 : -0.2;
                    group.add(ear);
                    // Inner ear
                    const innerEarGeometry = new THREE.CylinderGeometry(0.08, 0.15, 1.2, 8);
                    const innerEar = new THREE.Mesh(innerEarGeometry, innerEarMaterial);
                    innerEar.position.set(x, 5.2, 0.1);
                    innerEar.rotation.z = i === 0 ? 0.2 : -0.2;
                    group.add(innerEar);
                });

                // Big sparkling eyes
                const eyeGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeColor });
                [-0.3, 0.3].forEach(x => {
                    // Eye white
                    const whiteGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const whiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                    const white = new THREE.Mesh(whiteGeometry, whiteMaterial);
                    white.position.set(x, 4.1, 0.7);
                    group.add(white);
                    // Iris
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 4.1, 0.8);
                    group.add(eye);
                    // Sparkle
                    const sparkleGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                    const sparkleMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                    sparkle.position.set(x + 0.05, 4.15, 0.9);
                    group.add(sparkle);
                });

                // Cute nose
                const noseGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const noseMaterial = new THREE.MeshLambertMaterial({ color: noseColor });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(0, 3.8, 0.8);
                group.add(nose);

                // Whiskers
                const whiskerMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                [-0.3, 0.3].forEach(x => {
                    for (let i = 0; i < 3; i++) {
                        const whiskerGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.4, 4);
                        const whisker = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
                        whisker.position.set(x, 3.75 + i * 0.08, 0.7);
                        whisker.rotation.z = Math.PI / 2;
                        whisker.rotation.x = (i - 1) * 0.2;
                        group.add(whisker);
                    }
                });

                // Pink ribbon bow
                const ribbonMaterial = new THREE.MeshLambertMaterial({ color: ribbonColor });
                const bowLoop1 = new THREE.TorusGeometry(0.25, 0.08, 8, 16, Math.PI);
                const bow1 = new THREE.Mesh(bowLoop1, ribbonMaterial);
                bow1.position.set(-0.3, 4.5, 0.5);
                bow1.rotation.y = 0.5;
                group.add(bow1);
                const bow2 = new THREE.Mesh(bowLoop1, ribbonMaterial);
                bow2.position.set(0.3, 4.5, 0.5);
                bow2.rotation.y = -0.5;
                group.add(bow2);
                // Bow center
                const bowCenter = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), ribbonMaterial);
                bowCenter.position.set(0, 4.5, 0.6);
                group.add(bowCenter);

                // Golden basket
                const basketGeometry = new THREE.CylinderGeometry(0.5, 0.3, 0.4, 12, 1, true);
                const basketMaterial = new THREE.MeshLambertMaterial({ color: basketColor, side: THREE.DoubleSide });
                const basket = new THREE.Mesh(basketGeometry, basketMaterial);
                basket.position.set(1.5, 2.5, 0);
                group.add(basket);
                // Basket handle
                const handleGeometry = new THREE.TorusGeometry(0.35, 0.04, 8, 16, Math.PI);
                const handle = new THREE.Mesh(handleGeometry, basketMaterial);
                handle.position.set(1.5, 2.8, 0);
                handle.rotation.x = Math.PI / 2;
                group.add(handle);

                // Eggs in basket
                const eggColors = [0xFF69B4, 0x98FB98, 0x87CEEB, 0xFFD700, 0xE6E6FA];
                eggColors.forEach((color, i) => {
                    const eggGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                    const eggMaterial = new THREE.MeshLambertMaterial({ color });
                    const egg = new THREE.Mesh(eggGeometry, eggMaterial);
                    const angle = (i / 5) * Math.PI * 2;
                    egg.position.set(
                        1.5 + Math.cos(angle) * 0.2,
                        2.6,
                        Math.sin(angle) * 0.2
                    );
                    egg.scale.y = 1.3;
                    group.add(egg);
                });

                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1.0, 8);
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(1.2, 2.8, 0);
                leftArm.rotation.z = -0.8;
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(-1.0, 2.8, 0);
                rightArm.rotation.z = 0.5;
                group.add(rightArm);

                // Fluffy tail
                const tailGeometry = new THREE.SphereGeometry(0.4, 12, 12);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.position.set(0, 1.5, -1.2);
                group.add(tail);

                // Magic aura
                for (let i = 0; i < 15; i++) {
                    const auraGeometry = new THREE.SphereGeometry(0.08 + Math.random() * 0.06, 6, 6);
                    const auraMaterial = new THREE.MeshBasicMaterial({ 
                        color: [0xFFD700, 0xFF69B4, 0x98FB98, 0x87CEEB][i % 4],
                        transparent: true,
                        opacity: 0.7
                    });
                    const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                    aura.position.set(
                        (Math.random() - 0.5) * 3,
                        1 + Math.random() * 4,
                        (Math.random() - 0.5) * 2
                    );
                    group.add(aura);
                }

                return group;
            },

            // ========== LEVEL 11 EASTER ITEMS ==========

            'easter-egg': function() {
                const group = new THREE.Group();
                const eggColor = 0xFFE4E1;      // Base color
                const stripe1 = 0xFF69B4;       // Pink
                const stripe2 = 0x98FB98;       // Green
                const stripe3 = 0x87CEEB;       // Blue
                const dotColor = 0xFFD700;      // Gold dots

                // Main egg
                const eggGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const eggMaterial = new THREE.MeshLambertMaterial({ color: eggColor });
                const egg = new THREE.Mesh(eggGeometry, eggMaterial);
                egg.position.y = 0.5;
                egg.scale.set(0.8, 1.2, 0.8);
                group.add(egg);

                // Decorative stripes
                [stripe1, stripe2, stripe3].forEach((color, i) => {
                    const stripeGeometry = new THREE.TorusGeometry(0.32, 0.03, 8, 16);
                    const stripeMaterial = new THREE.MeshLambertMaterial({ color });
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.y = 0.3 + i * 0.2;
                    stripe.rotation.x = Math.PI / 2;
                    stripe.scale.set(0.8, 1, 0.8);
                    group.add(stripe);
                });

                // Golden dots
                for (let i = 0; i < 6; i++) {
                    const dotGeometry = new THREE.SphereGeometry(0.04, 6, 6);
                    const dotMaterial = new THREE.MeshBasicMaterial({ color: dotColor });
                    const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    dot.position.set(
                        Math.cos(angle) * 0.28,
                        0.5,
                        Math.sin(angle) * 0.28
                    );
                    group.add(dot);
                }

                // Sparkle effect
                const sparkleGeometry = new THREE.SphereGeometry(0.5, 12, 12);
                const sparkleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.2
                });
                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                sparkle.position.y = 0.5;
                group.add(sparkle);

                return group;
            },

            // ========== LEVEL 12 CHRISTMAS ENTITIES ==========

            'evil-elf': function() {
                const group = new THREE.Group();
                const elfGreen = 0x228b22;      // Forest green
                const elfRed = 0xdc143c;        // Crimson red
                const skinColor = 0xffdab9;     // Peach
                const hatRed = 0xb22222;        // Firebrick
                const eyeColor = 0xff0000;      // Red glowing eyes

                // Body with green tunic
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: elfGreen });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                group.add(body);

                // Red belt
                const beltGeometry = new THREE.BoxGeometry(0.62, 0.15, 0.42);
                const beltMaterial = new THREE.MeshLambertMaterial({ color: elfRed });
                const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                belt.position.y = 0.7;
                group.add(belt);

                // Belt buckle
                const buckleGeometry = new THREE.BoxGeometry(0.15, 0.12, 0.05);
                const buckleMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
                buckle.position.set(0, 0.7, 0.25);
                group.add(buckle);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.45;
                group.add(head);

                // Pointed ears
                const earGeometry = new THREE.ConeGeometry(0.12, 0.35, 8);
                const earMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                [-0.45, 0.45].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeometry, earMaterial);
                    ear.rotation.z = i === 0 ? Math.PI / 2 : -Math.PI / 2;
                    ear.position.set(x, 1.5, 0);
                    group.add(ear);
                });

                // Evil red glowing eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeColor });
                const eyeGeometry = new THREE.SphereGeometry(0.08, 12, 12);
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.45, 0.32);
                    group.add(eye);
                });

                // Pointy red hat
                const hatGeometry = new THREE.ConeGeometry(0.35, 0.6, 16);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: hatRed });
                const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                hat.position.y = 2.0;
                group.add(hat);

                // White pom-pom on hat
                const pomGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const pomMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const pom = new THREE.Mesh(pomGeometry, pomMaterial);
                pom.position.y = 2.3;
                group.add(pom);

                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.6, 8);
                const armMaterial = new THREE.MeshLambertMaterial({ color: elfGreen });
                [-0.45, 0.45].forEach(x => {
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.set(x, 0.8, 0);
                    arm.rotation.z = x < 0 ? 0.3 : -0.3;
                    group.add(arm);
                });

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.12, 0.1, 0.5, 8);
                const legMaterial = new THREE.MeshLambertMaterial({ color: elfRed });
                [-0.2, 0.2].forEach(x => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 0.25, 0);
                    group.add(leg);
                });

                // Curled toe shoes
                const shoeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const shoeMaterial = new THREE.MeshLambertMaterial({ color: elfGreen });
                [-0.2, 0.2].forEach(x => {
                    const shoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                    shoe.position.set(x, 0.05, 0.15);
                    shoe.scale.set(1, 0.6, 1.5);
                    group.add(shoe);
                });

                return group;
            },

            'evil-santa': function() {
                const group = new THREE.Group();
                const santaRed = 0xCC0000;      // Dark red coat
                const santaWhite = 0xFFFFFF;    // White trim
                const skinColor = 0xFFCCCC;     // Pale skin
                const beltColor = 0x222222;     // Black belt
                const buckleColor = 0xFFD700;   // Gold buckle
                const sledgeColor = 0x8B0000;   // Dark red sledge
                const sledgeRailColor = 0xFFD700; // Gold rails
                const eyeGlow = 0xFF0000;       // Evil red eyes
                
                // Large body with coat
                const bodyGeometry = new THREE.CylinderGeometry(1.0, 1.4, 2.5, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: santaRed });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 2.5;
                group.add(body);
                
                // White coat trim (bottom)
                const trimBottomGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 12);
                const trimMaterial = new THREE.MeshLambertMaterial({ color: santaWhite });
                const trimBottom = new THREE.Mesh(trimBottomGeometry, trimMaterial);
                trimBottom.position.y = 1.3;
                group.add(trimBottom);
                
                // White coat trim (middle)
                const trimMiddleGeometry = new THREE.CylinderGeometry(1.1, 1.1, 0.15, 12);
                const trimMiddle = new THREE.Mesh(trimMiddleGeometry, trimMaterial);
                trimMiddle.position.y = 3.7;
                group.add(trimMiddle);
                
                // Black belt
                const beltGeometry = new THREE.CylinderGeometry(1.05, 1.35, 0.25, 12);
                const beltMaterial = new THREE.MeshLambertMaterial({ color: beltColor });
                const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                belt.position.y = 2.3;
                group.add(belt);
                
                // Gold belt buckle
                const buckleGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.15);
                const buckleMaterial = new THREE.MeshLambertMaterial({ color: buckleColor });
                const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
                buckle.position.set(0, 2.3, 1.4);
                group.add(buckle);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 4.5;
                group.add(head);
                
                // Santa hat
                const hatGeometry = new THREE.ConeGeometry(0.7, 1.5, 12);
                const hat = new THREE.Mesh(hatGeometry, bodyMaterial);
                hat.position.y = 5.6;
                group.add(hat);
                
                // Hat trim
                const hatTrimGeometry = new THREE.CylinderGeometry(0.75, 0.75, 0.2, 12);
                const hatTrim = new THREE.Mesh(hatTrimGeometry, trimMaterial);
                hatTrim.position.y = 4.9;
                group.add(hatTrim);
                
                // Hat pom-pom
                const pomPomGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                const pomPom = new THREE.Mesh(pomPomGeometry, trimMaterial);
                pomPom.position.y = 6.3;
                group.add(pomPom);
                
                // Evil glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeGlow });
                [-0.3, 0.3].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 4.6, 0.7);
                    group.add(eye);
                    
                    // Evil glow effect
                    const glowGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const glowMaterial = new THREE.MeshBasicMaterial({ 
                        color: eyeGlow, 
                        transparent: true, 
                        opacity: 0.3 
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.position.set(x, 4.6, 0.7);
                    group.add(glow);
                });
                
                // Evil beard (darker, scraggly)
                const beardGeometry = new THREE.SphereGeometry(0.6, 12, 12);
                const beardMaterial = new THREE.MeshLambertMaterial({ color: 0xE0E0E0 });
                const beard = new THREE.Mesh(beardGeometry, beardMaterial);
                beard.position.set(0, 4.0, 0.6);
                beard.scale.set(1.2, 1.0, 0.8);
                group.add(beard);
                
                // Mustache
                [-0.3, 0.3].forEach(x => {
                    const mustacheGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                    const mustache = new THREE.Mesh(mustacheGeometry, beardMaterial);
                    mustache.position.set(x, 4.3, 0.65);
                    mustache.scale.set(1.5, 0.5, 0.8);
                    group.add(mustache);
                });
                
                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.3, 0.35, 1.8, 8);
                const armMaterial = new THREE.MeshLambertMaterial({ color: santaRed });
                [-1.3, 1.3].forEach((x, i) => {
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.set(x, 2.8, 0);
                    arm.rotation.z = i === 0 ? 0.4 : -0.4;
                    group.add(arm);
                    
                    // White cuff
                    const cuffGeometry = new THREE.CylinderGeometry(0.38, 0.38, 0.2, 8);
                    const cuff = new THREE.Mesh(cuffGeometry, trimMaterial);
                    const cuffOffset = i === 0 ? 
                        { x: x - 0.4, y: 2.2 } : 
                        { x: x + 0.4, y: 2.2 };
                    cuff.position.set(cuffOffset.x, cuffOffset.y, 0);
                    group.add(cuff);
                    
                    // Black gloves
                    const gloveGeometry = new THREE.SphereGeometry(0.35, 8, 8);
                    const gloveMaterial = new THREE.MeshLambertMaterial({ color: beltColor });
                    const glove = new THREE.Mesh(gloveGeometry, gloveMaterial);
                    const gloveOffset = i === 0 ? 
                        { x: x - 0.6, y: 1.8 } : 
                        { x: x + 0.6, y: 1.8 };
                    glove.position.set(gloveOffset.x, gloveOffset.y, 0);
                    group.add(glove);
                });
                
                // Flying Sledge
                const sledgeBaseGeometry = new THREE.BoxGeometry(3.0, 0.3, 1.5);
                const sledgeMaterial = new THREE.MeshLambertMaterial({ color: sledgeColor });
                const sledgeBase = new THREE.Mesh(sledgeBaseGeometry, sledgeMaterial);
                sledgeBase.position.set(0, 0.5, 0);
                group.add(sledgeBase);
                
                // Sledge curved front
                const sledgeFrontGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
                const sledgeFront = new THREE.Mesh(sledgeFrontGeometry, sledgeMaterial);
                sledgeFront.position.set(1.5, 0.6, 0);
                sledgeFront.rotation.x = Math.PI / 2;
                sledgeFront.rotation.z = 0.5;
                group.add(sledgeFront);
                
                // Gold rails (runners)
                const railGeometry = new THREE.BoxGeometry(3.5, 0.15, 0.2);
                const railMaterial = new THREE.MeshLambertMaterial({ color: sledgeRailColor });
                [-0.6, 0.6].forEach(z => {
                    const rail = new THREE.Mesh(railGeometry, railMaterial);
                    rail.position.set(0, 0.2, z);
                    group.add(rail);
                    
                    // Curved front of rail
                    const railFrontGeometry = new THREE.TorusGeometry(0.3, 0.1, 8, 16, Math.PI / 2);
                    const railFront = new THREE.Mesh(railFrontGeometry, railMaterial);
                    railFront.position.set(1.6, 0.3, z);
                    railFront.rotation.y = Math.PI / 2;
                    group.add(railFront);
                });
                
                // Gift bag on sledge (stolen presents!)
                const bagGeometry = new THREE.SphereGeometry(0.6, 12, 12);
                const bagMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const bag = new THREE.Mesh(bagGeometry, bagMaterial);
                bag.position.set(-1.0, 0.9, 0);
                bag.scale.set(1.2, 1.4, 1.0);
                group.add(bag);
                
                // Rope tied around bag
                const ropeGeometry = new THREE.TorusGeometry(0.5, 0.05, 8, 16);
                const ropeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const rope = new THREE.Mesh(ropeGeometry, ropeMaterial);
                rope.position.set(-1.0, 1.5, 0);
                rope.rotation.x = Math.PI / 2;
                group.add(rope);
                
                // Evil magical aura
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const radius = 2.5 + Math.random() * 0.5;
                    const sparkleGeometry = new THREE.SphereGeometry(0.08, 6, 6);
                    const sparkleMaterial = new THREE.MeshBasicMaterial({ 
                        color: Math.random() > 0.5 ? 0xFF0000 : 0x8B0000,
                        transparent: true,
                        opacity: 0.6
                    });
                    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                    sparkle.position.set(
                        Math.cos(angle) * radius,
                        2.5 + Math.sin(angle * 3) * 0.5,
                        Math.sin(angle) * radius
                    );
                    group.add(sparkle);
                }
                
                return group;
            },

            'giant-christmas': function() {
                const group = new THREE.Group();
                const snowWhite = 0xffffff;         // Snow white body
                const coalBlack = 0x222222;         // Coal eyes/buttons
                const carrotOrange = 0xff6600;      // Carrot nose
                const scarfRed = 0xdc143c;          // Red scarf
                const hatBlack = 0x1a1a1a;          // Black top hat
                const hatRibbon = 0xcc0000;         // Red hat ribbon
                const iceBlue = 0xccffff;           // Icy highlights
                
                // Large snowball body (bottom)
                const bodyBottomGeometry = new THREE.SphereGeometry(1.8, 16, 16);
                const snowMaterial = new THREE.MeshLambertMaterial({ color: snowWhite });
                const bodyBottom = new THREE.Mesh(bodyBottomGeometry, snowMaterial);
                bodyBottom.position.y = 2.0;
                bodyBottom.scale.set(1, 0.95, 1);
                group.add(bodyBottom);
                
                // Middle snowball
                const bodyMiddleGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const bodyMiddle = new THREE.Mesh(bodyMiddleGeometry, snowMaterial);
                bodyMiddle.position.y = 4.2;
                bodyMiddle.scale.set(1, 0.9, 1);
                group.add(bodyMiddle);
                
                // Coal buttons on body
                const buttonGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                const coalMaterial = new THREE.MeshLambertMaterial({ color: coalBlack });
                for (let i = 0; i < 3; i++) {
                    const button = new THREE.Mesh(buttonGeometry, coalMaterial);
                    button.position.set(0, 3.5 + (i * 0.5), 1.5);
                    group.add(button);
                }
                
                // Head (top snowball)
                const headGeometry = new THREE.SphereGeometry(1.2, 16, 16);
                const head = new THREE.Mesh(headGeometry, snowMaterial);
                head.position.y = 6.0;
                group.add(head);
                
                // Evil coal eyes (glowing red)
                const eyeGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                [-0.4, 0.4].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 6.2, 1.1);
                    group.add(eye);
                    
                    // Evil glow
                    const glowGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                    const glowMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xff0000, 
                        transparent: true, 
                        opacity: 0.3 
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.position.set(x, 6.2, 1.1);
                    group.add(glow);
                });
                
                // Carrot nose
                const noseGeometry = new THREE.ConeGeometry(0.15, 0.8, 8);
                const noseMaterial = new THREE.MeshLambertMaterial({ color: carrotOrange });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(0, 5.9, 1.2);
                nose.rotation.x = Math.PI / 2;
                group.add(nose);
                
                // Evil grin made of coal pieces
                const mouthCoalGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                for (let i = 0; i < 7; i++) {
                    const angle = (i - 3) * 0.15;
                    const x = Math.sin(angle) * 0.6;
                    const y = 5.5 - Math.abs(i - 3) * 0.08;
                    const mouthCoal = new THREE.Mesh(mouthCoalGeometry, coalMaterial);
                    mouthCoal.position.set(x, y, 1.1);
                    group.add(mouthCoal);
                }
                
                // Black top hat
                const hatBaseGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 16);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: hatBlack });
                const hatBase = new THREE.Mesh(hatBaseGeometry, hatMaterial);
                hatBase.position.y = 7.0;
                group.add(hatBase);
                
                const hatTopGeometry = new THREE.CylinderGeometry(0.6, 0.6, 1.2, 16);
                const hatTop = new THREE.Mesh(hatTopGeometry, hatMaterial);
                hatTop.position.y = 7.7;
                group.add(hatTop);
                
                // Red ribbon on hat
                const ribbonGeometry = new THREE.CylinderGeometry(0.65, 0.65, 0.15, 16);
                const ribbonMaterial = new THREE.MeshLambertMaterial({ color: hatRibbon });
                const ribbon = new THREE.Mesh(ribbonGeometry, ribbonMaterial);
                ribbon.position.y = 7.2;
                group.add(ribbon);
                
                // Red scarf around neck
                const scarfMaterial = new THREE.MeshLambertMaterial({ color: scarfRed });
                const scarfRingGeometry = new THREE.TorusGeometry(1.3, 0.2, 8, 16);
                const scarfRing = new THREE.Mesh(scarfRingGeometry, scarfMaterial);
                scarfRing.position.y = 5.2;
                scarfRing.rotation.x = Math.PI / 2;
                group.add(scarfRing);
                
                // Scarf tails hanging down
                const scarfTailGeometry = new THREE.CylinderGeometry(0.18, 0.15, 1.5, 8);
                [-0.9, 0.9].forEach(x => {
                    const tail = new THREE.Mesh(scarfTailGeometry, scarfMaterial);
                    tail.position.set(x, 4.2, 0.8);
                    tail.rotation.z = x < 0 ? 0.2 : -0.2;
                    group.add(tail);
                });
                
                // Stick arms (frozen tree branches)
                const stickMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
                const armGeometry = new THREE.CylinderGeometry(0.15, 0.12, 2.5, 8);
                
                const leftArm = new THREE.Mesh(armGeometry, stickMaterial);
                leftArm.position.set(-1.8, 4.5, 0);
                leftArm.rotation.z = Math.PI / 3;
                group.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeometry, stickMaterial);
                rightArm.position.set(1.8, 4.5, 0);
                rightArm.rotation.z = -Math.PI / 3;
                group.add(rightArm);
                
                // Stick fingers (3 per hand)
                const fingerGeometry = new THREE.CylinderGeometry(0.05, 0.04, 0.6, 6);
                [[-2.7, 3.8], [2.7, 3.8]].forEach(([x, y], armIndex) => {
                    for (let i = 0; i < 3; i++) {
                        const finger = new THREE.Mesh(fingerGeometry, stickMaterial);
                        const angleOffset = (i - 1) * 0.3;
                        finger.position.set(
                            x + Math.sin(angleOffset) * 0.2,
                            y + Math.cos(angleOffset) * 0.2,
                            0
                        );
                        finger.rotation.z = armIndex === 0 ? 
                            (Math.PI / 3 + angleOffset) : 
                            (-Math.PI / 3 + angleOffset);
                        group.add(finger);
                    }
                });
                
                // Icy highlights/frost patches
                const frostMaterial = new THREE.MeshLambertMaterial({ 
                    color: iceBlue, 
                    transparent: true, 
                    opacity: 0.4 
                });
                const frostGeometry = new THREE.SphereGeometry(0.3, 12, 12);
                [
                    [0.8, 4.5, 1.4],
                    [-0.9, 3.2, 1.6],
                    [0.5, 6.3, 1.0],
                    [-0.6, 2.5, 1.7]
                ].forEach(([x, y, z]) => {
                    const frost = new THREE.Mesh(frostGeometry, frostMaterial);
                    frost.position.set(x, y, z);
                    frost.scale.set(1.2, 0.8, 0.6);
                    group.add(frost);
                });
                
                return group;
            },

            'little-princess': function() {
                const group = new THREE.Group();
                const dressColor = 0xFFB6C1;        // Light pink dress
                const skinColor = 0xFFDFC4;         // Peachy skin
                const crownGold = 0xFFD700;         // Gold crown
                const hairColor = 0xFFE4B5;         // Blonde hair
                const shoeColor = 0xFF69B4;         // Hot pink shoes
                
                // Pink dress body (cone)
                const bodyGeometry = new THREE.ConeGeometry(0.4, 0.8, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: dressColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.6;
                group.add(body);
                
                // White lace trim
                const laceGeometry = new THREE.TorusGeometry(0.4, 0.04, 8, 16);
                const laceMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const lace = new THREE.Mesh(laceGeometry, laceMaterial);
                lace.position.y = 0.2;
                lace.rotation.x = Math.PI / 2;
                group.add(lace);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.35;
                group.add(head);
                
                // Blonde hair buns
                const bunGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                const hairMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
                [-0.25, 0.25].forEach(x => {
                    const bun = new THREE.Mesh(bunGeometry, hairMaterial);
                    bun.position.set(x, 1.55, -0.1);
                    group.add(bun);
                });
                
                // Little Crown
                const crownBaseGeometry = new THREE.CylinderGeometry(0.15, 0.18, 0.1, 8);
                const crownMaterial = new THREE.MeshLambertMaterial({ color: crownGold });
                const crownBase = new THREE.Mesh(crownBaseGeometry, crownMaterial);
                crownBase.position.y = 1.75;
                group.add(crownBase);
                
                // Crown points
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const pointGeometry = new THREE.ConeGeometry(0.03, 0.12, 4);
                    const point = new THREE.Mesh(pointGeometry, crownMaterial);
                    point.position.set(
                        Math.cos(angle) * 0.12,
                        1.85,
                        Math.sin(angle) * 0.12
                    );
                    group.add(point);
                }
                
                // Cute eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x4169E1 });
                const eyeGeometry = new THREE.SphereGeometry(0.08, 12, 12);
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.4, 0.3);
                    group.add(eye);
                });
                
                // Angry eyebrows
                const browGeometry = new THREE.BoxGeometry(0.12, 0.02, 0.02);
                const browMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
                [-0.12, 0.12].forEach((x, i) => {
                    const brow = new THREE.Mesh(browGeometry, browMaterial);
                    brow.position.set(x, 1.52, 0.32);
                    brow.rotation.z = i === 0 ? -0.3 : 0.3;
                    group.add(brow);
                });
                
                // Little arms
                const armGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                [-0.35, 0.35].forEach((x, i) => {
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.set(x, 0.9, 0);
                    arm.rotation.z = i === 0 ? 0.5 : -0.5;
                    group.add(arm);
                });
                
                // Pink shoes
                const shoeGeometry = new THREE.BoxGeometry(0.12, 0.08, 0.2);
                const shoeMaterial = new THREE.MeshLambertMaterial({ color: shoeColor });
                [-0.15, 0.15].forEach(x => {
                    const shoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                    shoe.position.set(x, 0.04, 0.05);
                    group.add(shoe);
                });
                
                return group;
            },

            'rapunzel-witch': function() {
                const group = new THREE.Group();
                const cloakColor = 0x2D1B4E;        // Dark purple cloak
                const skinColor = 0x98FB98;         // Pale green witch skin
                const hatColor = 0x1A0F2E;          // Very dark purple hat
                const hairColor = 0x1C1C1C;         // Black hair
                const gemColor = 0x00FF7F;          // Green magic
                
                // Witch cloak body
                const cloakGeometry = new THREE.ConeGeometry(0.6, 1.6, 8);
                const cloakMaterial = new THREE.MeshLambertMaterial({ color: cloakColor });
                const cloak = new THREE.Mesh(cloakGeometry, cloakMaterial);
                cloak.position.y = 1.0;
                group.add(cloak);
                
                // Witch head
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.0;
                group.add(head);
                
                // Big warty nose
                const noseGeometry = new THREE.ConeGeometry(0.1, 0.25, 6);
                const nose = new THREE.Mesh(noseGeometry, headMaterial);
                nose.position.set(0, 1.95, 0.42);
                nose.rotation.x = Math.PI / 2; // Point forward
                group.add(nose);
                
                // Wart
                const wartGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const wartMaterial = new THREE.MeshLambertMaterial({ color: 0x556B2F });
                const wart = new THREE.Mesh(wartGeometry, wartMaterial);
                wart.position.set(0.05, 1.98, 0.55);
                group.add(wart);
                
                // Evil eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4500 });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 12, 12);
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 2.1, 0.35);
                    group.add(eye);
                });
                
                // Pointed witch hat
                const hatBrimGeometry = new THREE.CylinderGeometry(0.55, 0.55, 0.08, 16);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: hatColor });
                const hatBrim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
                hatBrim.position.y = 2.35;
                group.add(hatBrim);
                
                const hatConeGeometry = new THREE.ConeGeometry(0.35, 0.9, 12);
                const hatCone = new THREE.Mesh(hatConeGeometry, hatMaterial);
                hatCone.position.y = 2.85;
                group.add(hatCone);
                
                // Hat buckle
                const buckleGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.05);
                const buckleMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
                buckle.position.set(0, 2.5, 0.32);
                group.add(buckle);
                
                // Staff
                const staffGeometry = new THREE.CylinderGeometry(0.04, 0.06, 2.2, 6);
                const staffMaterial = new THREE.MeshLambertMaterial({ color: 0x3D2817 });
                const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                staff.position.set(0.65, 1.1, 0.2);
                staff.rotation.z = -0.15;
                group.add(staff);
                
                // Pine cone on staff
                const pineConeGeometry = new THREE.ConeGeometry(0.12, 0.25, 8);
                const pineConeMaterial = new THREE.MeshLambertMaterial({ color: gemColor });
                const pineCone = new THREE.Mesh(pineConeGeometry, pineConeMaterial);
                pineCone.position.set(0.72, 2.3, 0.2);
                group.add(pineCone);
                
                // Magic glow
                const glowGeometry = new THREE.SphereGeometry(0.18, 12, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({ color: gemColor, transparent: true, opacity: 0.4 });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(0.72, 2.3, 0.2);
                group.add(glow);
                
                return group;
            },

            'tower-giant': function() {
                const group = new THREE.Group();
                const stoneColor = 0x7A7A7A;
                const stoneDark = 0x5A5A5A;
                const mossColor = 0x4A5D3A;
                const eyeGlow = 0xFF6600;
                const doorColor = 0x4A3A2A;
                
                // Main tower body
                const towerGeometry = new THREE.CylinderGeometry(1.8, 2.2, 5.0, 12);
                const towerMaterial = new THREE.MeshLambertMaterial({ color: stoneColor });
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.y = 3.0;
                group.add(tower);
                
                // Battlements on top
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const battlementGeometry = new THREE.BoxGeometry(0.8, 1.0, 0.5);
                    const battlementMaterial = new THREE.MeshLambertMaterial({ color: stoneDark });
                    const battlement = new THREE.Mesh(battlementGeometry, battlementMaterial);
                    battlement.position.set(
                        Math.cos(angle) * 1.6,
                        6.0,
                        Math.sin(angle) * 1.6
                    );
                    battlement.rotation.y = -angle;
                    group.add(battlement);
                }
                
                // Glowing eyes
                const eyeGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.2);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeGlow });
                [-0.7, 0.7].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 4.5, 1.9);
                    group.add(eye);
                });
                
                // Angry eyebrows
                const browGeometry = new THREE.BoxGeometry(0.7, 0.15, 0.2);
                const browMaterial = new THREE.MeshLambertMaterial({ color: stoneDark });
                [-0.7, 0.7].forEach((x, i) => {
                    const brow = new THREE.Mesh(browGeometry, browMaterial);
                    brow.position.set(x, 5.0, 1.9);
                    brow.rotation.z = i === 0 ? -0.3 : 0.3;
                    group.add(brow);
                });
                
                // Mouth door
                const mouthGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.2);
                const mouthMaterial = new THREE.MeshLambertMaterial({ color: doorColor });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 3.0, 2.0);
                group.add(mouth);
                
                // Teeth
                for (let i = 0; i < 4; i++) {
                    const toothGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.15);
                    const toothMaterial = new THREE.MeshLambertMaterial({ color: 0xE8E8E8 });
                    const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                    tooth.position.set(-0.45 + i * 0.3, 3.4, 2.05);
                    group.add(tooth);
                }
                
                // Nose
                const noseGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.4);
                const nose = new THREE.Mesh(noseGeometry, towerMaterial);
                nose.position.set(0, 3.8, 2.1);
                group.add(nose);
                
                // Moss patches
                const mossGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const mossMaterial = new THREE.MeshLambertMaterial({ color: mossColor });
                [[1.5, 2.0, 1.0], [-1.6, 3.5, 0.8]].forEach(pos => {
                    const moss = new THREE.Mesh(mossGeometry, mossMaterial);
                    moss.position.set(pos[0], pos[1], pos[2]);
                    moss.scale.set(1.5, 0.5, 1);
                    group.add(moss);
                });
                
                // Stone legs
                const legGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.0, 8);
                const legMaterial = new THREE.MeshLambertMaterial({ color: stoneDark });
                [-1.0, 1.0].forEach(x => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 0.5, 0);
                    group.add(leg);
                });
                
                // Stone arms
                const armGeometry = new THREE.CylinderGeometry(0.35, 0.45, 2.5, 8);
                [-2.3, 2.3].forEach((x, i) => {
                    const arm = new THREE.Mesh(armGeometry, towerMaterial);
                    arm.position.set(x, 3.5, 0);
                    arm.rotation.z = i === 0 ? 0.4 : -0.4;
                    group.add(arm);
                });
                
                return group;
            },

            'crown-wizard': function() {
                const group = new THREE.Group();
                const crownGold = 0xFFD700;
                const crownDarkGold = 0xDAA520;
                const gemRed = 0xFF0000;
                const gemBlue = 0x0066FF;
                const legColor = 0x8B6914;
                const eyeGlow = 0xFF4500;
                
                // Main crown base
                const crownBaseGeometry = new THREE.CylinderGeometry(1.2, 1.4, 0.8, 16);
                const crownMaterial = new THREE.MeshLambertMaterial({ color: crownGold });
                const crownBase = new THREE.Mesh(crownBaseGeometry, crownMaterial);
                crownBase.position.y = 2.4;
                group.add(crownBase);
                
                // Crown rim
                const rimGeometry = new THREE.TorusGeometry(1.3, 0.1, 8, 24);
                const rimMaterial = new THREE.MeshLambertMaterial({ color: crownDarkGold });
                const topRim = new THREE.Mesh(rimGeometry, rimMaterial);
                topRim.position.y = 2.8;
                topRim.rotation.x = Math.PI / 2;
                group.add(topRim);
                
                // Crown points
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const pointGeometry = new THREE.ConeGeometry(0.25, 1.2, 6);
                    const point = new THREE.Mesh(pointGeometry, crownMaterial);
                    point.position.set(
                        Math.cos(angle) * 1.0,
                        3.4,
                        Math.sin(angle) * 1.0
                    );
                    group.add(point);
                    
                    // Gem on each point
                    const gemColors = [gemRed, gemBlue, 0x00FF00];
                    const gemGeometry = new THREE.OctahedronGeometry(0.15, 0);
                    const gemMaterial = new THREE.MeshLambertMaterial({ color: gemColors[i % 3] });
                    const gem = new THREE.Mesh(gemGeometry, gemMaterial);
                    gem.position.set(
                        Math.cos(angle) * 1.0,
                        4.1,
                        Math.sin(angle) * 1.0
                    );
                    group.add(gem);
                }
                
                // Evil eyes
                const eyeGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeGlow });
                [-0.4, 0.4].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 2.6, 1.35);
                    group.add(eye);
                });
                
                // Large center gem
                const centerGemGeometry = new THREE.OctahedronGeometry(0.35, 0);
                const centerGemMaterial = new THREE.MeshLambertMaterial({ color: gemRed });
                const centerGem = new THREE.Mesh(centerGemGeometry, centerGemMaterial);
                centerGem.position.set(0, 2.4, 1.5);
                centerGem.rotation.y = Math.PI / 4;
                group.add(centerGem);
                
                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.2, 1.8, 8);
                const legMaterial = new THREE.MeshLambertMaterial({ color: legColor });
                [-0.6, 0.6].forEach(x => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 1.0, 0);
                    group.add(leg);
                });
                
                // Feet
                const footGeometry = new THREE.BoxGeometry(0.4, 0.15, 0.5);
                const footMaterial = new THREE.MeshLambertMaterial({ color: crownGold });
                [-0.6, 0.6].forEach(x => {
                    const foot = new THREE.Mesh(footGeometry, footMaterial);
                    foot.position.set(x, 0.1, 0.1);
                    group.add(foot);
                });
                
                // Small arms
                const armGeometry = new THREE.CylinderGeometry(0.08, 0.1, 1.2, 6);
                [-1.3, 1.3].forEach((x, i) => {
                    const arm = new THREE.Mesh(armGeometry, legMaterial);
                    arm.position.set(x, 2.2, 0);
                    arm.rotation.z = i === 0 ? 0.6 : -0.6;
                    group.add(arm);
                    
                    // Orb at end
                    const orbGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                    const orbMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4500 });
                    const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                    orb.position.set(x * 1.35, 1.6, 0);
                    group.add(orb);
                });
                
                return group;
            },

            'rapunzel': function() {
                const group = new THREE.Group();
                const dressColor = 0x9370DB;        // Medium purple dress
                const skinColor = 0xFFDFC4;         // Peachy skin
                const hairGold = 0xFFD700;          // Golden hair
                
                // Purple dress body
                const bodyGeometry = new THREE.ConeGeometry(0.5, 1.2, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: dressColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                body.rotation.x = Math.PI;
                group.add(body);
                
                // White dress details
                const laceGeometry = new THREE.TorusGeometry(0.5, 0.04, 8, 16);
                const laceMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const lace = new THREE.Mesh(laceGeometry, laceMaterial);
                lace.position.y = 0.2;
                lace.rotation.x = Math.PI / 2;
                group.add(lace);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.9;
                group.add(head);
                
                // Beautiful eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x32CD32 });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 12, 12);
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.95, 0.35);
                    group.add(eye);
                });
                
                // Smile
                const smileGeometry = new THREE.TorusGeometry(0.1, 0.02, 8, 8, Math.PI);
                const smileMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B6B });
                const smile = new THREE.Mesh(smileGeometry, smileMaterial);
                smile.position.set(0, 1.75, 0.38);
                smile.rotation.x = Math.PI;
                group.add(smile);
                
                // Long golden braided hair
                const hairMaterial = new THREE.MeshLambertMaterial({ color: hairGold });
                
                // Hair top
                const hairTopGeometry = new THREE.SphereGeometry(0.38, 16, 16);
                const hairTop = new THREE.Mesh(hairTopGeometry, hairMaterial);
                hairTop.position.set(0, 2.1, -0.1);
                group.add(hairTop);
                
                // Long braid going down
                for (let i = 0; i < 10; i++) {
                    const braidGeometry = new THREE.SphereGeometry(0.12 - i * 0.008, 8, 8);
                    const braid = new THREE.Mesh(braidGeometry, hairMaterial);
                    braid.position.set(0, 1.5 - i * 0.2, -0.35);
                    group.add(braid);
                }
                
                // Flowers in hair
                const flowerColors = [0xFF69B4, 0xFFB6C1, 0xFF1493];
                for (let i = 0; i < 3; i++) {
                    const flowerGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                    const flowerMaterial = new THREE.MeshLambertMaterial({ color: flowerColors[i] });
                    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.set(
                        0.2 * Math.cos(i * 1.2),
                        2.2,
                        0.2 * Math.sin(i * 1.2)
                    );
                    group.add(flower);
                }
                
                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.5, 6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                [-0.4, 0.4].forEach((x, i) => {
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.set(x, 1.3, 0);
                    arm.rotation.z = i === 0 ? 0.4 : -0.4;
                    group.add(arm);
                });
                
                return group;
            },

            // === Flying Witch (Level 14) ===
            'flying-witch': function() {
                const group = new THREE.Group();
                const cloakColor = 0x2D1B4E;
                const skinColor = 0x98FB98;
                const hatColor = 0x1A0F2E;
                const broomColor = 0x5D4037;
                const bristleColor = 0x8B7355;
                const eyeGlow = 0x00FF00;
                
                // Broomstick handle
                const handleGeometry = new THREE.CylinderGeometry(0.08, 0.1, 3, 8);
                const handleMaterial = new THREE.MeshLambertMaterial({ color: broomColor });
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.rotation.x = Math.PI / 2;
                group.add(handle);
                
                // Bristles
                const bristleGeometry = new THREE.ConeGeometry(0.35, 1.0, 8);
                const bristleMaterial = new THREE.MeshLambertMaterial({ color: bristleColor });
                const bristles = new THREE.Mesh(bristleGeometry, bristleMaterial);
                bristles.rotation.x = -Math.PI / 2;
                bristles.position.z = -2.0;
                group.add(bristles);
                
                // Witch cloak body
                const cloakGeometry = new THREE.ConeGeometry(0.45, 1.0, 8);
                const cloakMaterial = new THREE.MeshLambertMaterial({ color: cloakColor });
                const cloak = new THREE.Mesh(cloakGeometry, cloakMaterial);
                cloak.position.y = 0.7;
                cloak.position.z = 0.4;
                group.add(cloak);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.32, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.45;
                head.position.z = 0.4;
                group.add(head);
                
                // Pointy nose
                const noseGeometry = new THREE.ConeGeometry(0.07, 0.18, 6);
                const nose = new THREE.Mesh(noseGeometry, headMaterial);
                nose.position.set(0, 1.4, 0.75);
                nose.rotation.x = Math.PI / 2;
                group.add(nose);
                
                // Green glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.07, 12, 12);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: eyeGlow });
                [-0.1, 0.1].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.5, 0.68);
                    group.add(eye);
                });
                
                // Witch hat
                const hatBrimGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.05, 16);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: hatColor });
                const hatBrim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
                hatBrim.position.y = 1.75;
                hatBrim.position.z = 0.4;
                group.add(hatBrim);
                
                const hatConeGeometry = new THREE.ConeGeometry(0.25, 0.7, 12);
                const hatCone = new THREE.Mesh(hatConeGeometry, hatMaterial);
                hatCone.position.y = 2.15;
                hatCone.position.z = 0.4;
                hatCone.rotation.z = 0.15;
                group.add(hatCone);
                
                return group;
            },

            // === Flying Witch House (Level 14) ===
            'flying-witch-house': function() {
                const group = new THREE.Group();
                const woodColor = 0x5D4E37;
                const roofColor = 0x3D2817;
                const windowGlow = 0x88FF88;
                const cloudColor = 0xE8E8FF;
                
                // Cloud base
                const cloudMaterial = new THREE.MeshLambertMaterial({ color: cloudColor, transparent: true, opacity: 0.85 });
                const cloudPositions = [
                    { x: 0, y: -1.5, z: 0, r: 1.8 },
                    { x: 1.4, y: -1.6, z: 0.7, r: 1.4 },
                    { x: -1.5, y: -1.5, z: 0.3, r: 1.5 },
                    { x: 0.7, y: -1.7, z: -1.0, r: 1.3 },
                    { x: -1.0, y: -1.6, z: -0.8, r: 1.4 }
                ];
                cloudPositions.forEach(pos => {
                    const cloudGeometry = new THREE.SphereGeometry(pos.r, 12, 10);
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloud.position.set(pos.x, pos.y, pos.z);
                    group.add(cloud);
                });
                
                // House body
                const houseGeometry = new THREE.BoxGeometry(2.8, 2.2, 2.4);
                const houseMaterial = new THREE.MeshLambertMaterial({ color: woodColor });
                const house = new THREE.Mesh(houseGeometry, houseMaterial);
                house.position.y = 1.1;
                group.add(house);
                
                // Pointy roof
                const roofGeometry = new THREE.ConeGeometry(2.5, 2.2, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: roofColor });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = 3.3;
                roof.rotation.y = Math.PI / 4;
                group.add(roof);
                
                // Crooked chimney
                const chimneyGeometry = new THREE.BoxGeometry(0.45, 1.1, 0.45);
                const chimneyMaterial = new THREE.MeshLambertMaterial({ color: 0x6B4423 });
                const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
                chimney.position.set(0.9, 2.8, 0.6);
                chimney.rotation.z = 0.12;
                group.add(chimney);
                
                // Glowing windows
                const windowMaterial = new THREE.MeshBasicMaterial({ color: windowGlow, transparent: true, opacity: 0.9 });
                const windowGeometry = new THREE.PlaneGeometry(0.5, 0.5);
                [-0.6, 0.6].forEach(x => {
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.set(x, 1.4, 1.21);
                    group.add(window);
                });
                
                // Door
                const doorGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.1);
                const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x2D1B1B });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(0, 0.5, 1.21);
                group.add(door);
                
                return group;
            },

            // === Crystal Goblin / Cave Crawler (Level 13) ===
            'crystal-goblin': function() {
                const group = new THREE.Group();
                const biolumGreen = 0x44ffaa;      // Bioluminescent skin
                const crystalPurple = 0xaa44ff;   // Crystal accents
                const crystalBlue = 0x44aaff;     // Secondary glow
                const darkCave = 0x2a2a4a;        // Dark cave clothing
                const glowWhite = 0xccffee;       // Bright glow spots
                
                // Body - dark cave clothing
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: darkCave });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                group.add(body);
                
                // Crystal shard belt
                const beltGeometry = new THREE.BoxGeometry(0.65, 0.12, 0.42);
                const beltMaterial = new THREE.MeshLambertMaterial({ color: crystalPurple });
                const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                belt.position.y = 0.7;
                group.add(belt);
                
                // Crystal on belt
                const beltCrystalGeometry = new THREE.OctahedronGeometry(0.1, 0);
                const beltCrystalMaterial = new THREE.MeshBasicMaterial({ color: crystalBlue });
                const beltCrystal = new THREE.Mesh(beltCrystalGeometry, beltCrystalMaterial);
                beltCrystal.position.set(0, 0.7, 0.23);
                beltCrystal.rotation.y = Math.PI / 4;
                group.add(beltCrystal);
                
                // Head - bioluminescent green
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: biolumGreen });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.5;
                group.add(head);
                
                // Glowing eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: glowWhite });
                const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.5, 0.35);
                    group.add(eye);
                });
                
                // Bioluminescent spots on face
                const spotMaterial = new THREE.MeshBasicMaterial({ color: glowWhite });
                const spotGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                [[-0.25, 1.6, 0.25], [0.25, 1.6, 0.25], [-0.1, 1.35, 0.38], [0.1, 1.35, 0.38]].forEach(pos => {
                    const spot = new THREE.Mesh(spotGeometry, spotMaterial);
                    spot.position.set(pos[0], pos[1], pos[2]);
                    group.add(spot);
                });
                
                // Pointed ears - bioluminescent
                const earGeometry = new THREE.ConeGeometry(0.15, 0.4, 4);
                const earMaterial = new THREE.MeshLambertMaterial({ color: biolumGreen });
                [-0.5, 0.5].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeometry, earMaterial);
                    ear.rotation.z = i === 0 ? Math.PI / 2 : -Math.PI / 2;
                    ear.position.set(x, 1.5, 0);
                    group.add(ear);
                });
                
                // Crystal growths on head
                const headCrystalGeometry = new THREE.ConeGeometry(0.08, 0.35, 5);
                const headCrystalMaterial = new THREE.MeshBasicMaterial({ color: crystalPurple });
                const headCrystal1 = new THREE.Mesh(headCrystalGeometry, headCrystalMaterial);
                headCrystal1.position.set(-0.15, 1.95, 0);
                headCrystal1.rotation.z = 0.3;
                group.add(headCrystal1);
                
                const headCrystal2 = new THREE.Mesh(headCrystalGeometry, headCrystalMaterial);
                headCrystal2.position.set(0.1, 2.0, 0.05);
                headCrystal2.rotation.z = -0.2;
                headCrystal2.scale.set(0.8, 1.2, 0.8);
                group.add(headCrystal2);
                
                const headCrystal3Geometry = new THREE.ConeGeometry(0.06, 0.25, 5);
                const headCrystal3Material = new THREE.MeshBasicMaterial({ color: crystalBlue });
                const headCrystal3 = new THREE.Mesh(headCrystal3Geometry, headCrystal3Material);
                headCrystal3.position.set(0.2, 1.9, -0.1);
                headCrystal3.rotation.z = -0.4;
                group.add(headCrystal3);
                
                return group;
            },

            // === Crystal Guardian / Crystal Sentinel (Level 13) ===
            'crystal-guardian': function() {
                const group = new THREE.Group();
                const crystalPurple = 0x8844ff;
                const crystalPink = 0xff44aa;
                const crystalGlow = 0xaa88ff;
                const crystalDark = 0x5522aa;
                
                // Faceted crystal body
                const bodyGeometry = new THREE.OctahedronGeometry(0.55, 0);
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: crystalPurple, 
                    transparent: true, 
                    opacity: 0.85 
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.0;
                body.scale.set(0.9, 1.2, 0.7);
                group.add(body);
                
                // Inner core glow
                const coreGeometry = new THREE.OctahedronGeometry(0.3, 0);
                const coreMaterial = new THREE.MeshBasicMaterial({ 
                    color: crystalGlow, 
                    transparent: true, 
                    opacity: 0.6 
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 1.0;
                group.add(core);
                
                // Angular crystal head
                const headGeometry = new THREE.OctahedronGeometry(0.4, 0);
                const headMaterial = new THREE.MeshLambertMaterial({ 
                    color: crystalPurple, 
                    transparent: true, 
                    opacity: 0.85 
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.85;
                head.rotation.y = Math.PI / 4;
                group.add(head);
                
                // Glowing gem eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const eyeGeometry = new THREE.OctahedronGeometry(0.1, 0);
                [-0.15, 0.15].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.85, 0.32);
                    eye.rotation.y = Math.PI / 4;
                    group.add(eye);
                });
                
                // Crystal crown spikes
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const spike = new THREE.Mesh(
                        new THREE.ConeGeometry(0.08, 0.35, 4),
                        new THREE.MeshLambertMaterial({ color: crystalPink, transparent: true, opacity: 0.8 })
                    );
                    spike.position.set(Math.cos(angle) * 0.28, 2.15, Math.sin(angle) * 0.28);
                    spike.rotation.x = Math.cos(angle) * 0.3;
                    spike.rotation.z = -Math.sin(angle) * 0.3;
                    group.add(spike);
                }
                
                // Crystal shoulders
                [-0.55, 0.55].forEach(x => {
                    const shoulder = new THREE.Mesh(
                        new THREE.OctahedronGeometry(0.2, 0),
                        new THREE.MeshLambertMaterial({ color: crystalDark, transparent: true, opacity: 0.85 })
                    );
                    shoulder.position.set(x, 1.4, 0);
                    shoulder.rotation.z = x > 0 ? -0.5 : 0.5;
                    group.add(shoulder);
                });
                
                return group;
            },

            // === Crystal Wizard / Gem Mage (Level 13) ===
            'crystal-wizard': function() {
                const group = new THREE.Group();
                const crystalPink = 0xff44aa;
                const crystalPurple = 0xaa44ff;
                const crystalGlow = 0xff88cc;
                const crystalDark = 0x8822aa;
                
                // Crystal robe body - hexagonal
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.9, 2.5, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: crystalPink, 
                    transparent: true, 
                    opacity: 0.85 
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                group.add(body);
                
                // Inner robe glow
                const innerGlowGeometry = new THREE.CylinderGeometry(0.35, 0.7, 2.3, 6);
                const innerGlowMaterial = new THREE.MeshBasicMaterial({ 
                    color: crystalGlow, 
                    transparent: true, 
                    opacity: 0.4 
                });
                const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
                innerGlow.position.y = 1.5;
                group.add(innerGlow);
                
                // Crystal collar
                const collarGeometry = new THREE.TorusGeometry(0.55, 0.12, 6, 6);
                const collarMaterial = new THREE.MeshLambertMaterial({ 
                    color: crystalPurple, 
                    transparent: true, 
                    opacity: 0.9 
                });
                const collar = new THREE.Mesh(collarGeometry, collarMaterial);
                collar.rotation.x = Math.PI / 2;
                collar.position.y = 2.7;
                group.add(collar);
                
                // Octahedron head
                const headGeometry = new THREE.OctahedronGeometry(0.55, 0);
                const headMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xffccee, 
                    transparent: true, 
                    opacity: 0.9 
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.2;
                head.scale.set(1.0, 0.85, 0.9);
                head.rotation.y = Math.PI / 4;
                group.add(head);
                
                // Crystal wizard hat
                const hatGeometry = new THREE.ConeGeometry(0.65, 1.6, 6);
                const hatMaterial = new THREE.MeshLambertMaterial({ 
                    color: crystalDark, 
                    transparent: true, 
                    opacity: 0.85 
                });
                const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                hat.position.y = 4.3;
                group.add(hat);
                
                // Hat inner glow
                const hatGlowGeometry = new THREE.ConeGeometry(0.45, 1.4, 6);
                const hatGlowMaterial = new THREE.MeshBasicMaterial({ 
                    color: crystalPink, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const hatGlow = new THREE.Mesh(hatGlowGeometry, hatGlowMaterial);
                hatGlow.position.y = 4.3;
                group.add(hatGlow);
                
                // Hat brim
                const brimGeometry = new THREE.TorusGeometry(0.7, 0.12, 6, 6);
                const brimMaterial = new THREE.MeshLambertMaterial({ 
                    color: crystalPink, 
                    transparent: true, 
                    opacity: 0.85 
                });
                const brim = new THREE.Mesh(brimGeometry, brimMaterial);
                brim.rotation.x = Math.PI / 2;
                brim.position.y = 3.6;
                group.add(brim);
                
                // Crystal spikes on hat tip
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const spike = new THREE.Mesh(
                        new THREE.ConeGeometry(0.08, 0.35, 4),
                        new THREE.MeshBasicMaterial({ color: crystalGlow, transparent: true, opacity: 0.8 })
                    );
                    spike.position.set(Math.cos(angle) * 0.25, 5.0, Math.sin(angle) * 0.25);
                    spike.rotation.x = Math.cos(angle) * 0.4;
                    spike.rotation.z = -Math.sin(angle) * 0.4;
                    group.add(spike);
                }
                
                // Glowing gem eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const eyeGeometry = new THREE.OctahedronGeometry(0.1, 0);
                [-0.2, 0.2].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 3.15, 0.45);
                    eye.rotation.y = Math.PI / 4;
                    group.add(eye);
                });
                
                // Crystal staff
                const staffGeometry = new THREE.CylinderGeometry(0.06, 0.1, 3.0, 6);
                const staffMaterial = new THREE.MeshLambertMaterial({ 
                    color: crystalPurple, 
                    transparent: true, 
                    opacity: 0.85 
                });
                const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                staff.position.set(0.85, 1.5, 0.3);
                staff.rotation.z = -0.2;
                group.add(staff);
                
                // Gem orb on staff
                const orbGeometry = new THREE.OctahedronGeometry(0.3, 0);
                const orbMaterial = new THREE.MeshBasicMaterial({ 
                    color: crystalPink, 
                    transparent: true, 
                    opacity: 0.9 
                });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.set(0.95, 3.1, 0.35);
                orb.rotation.y = Math.PI / 4;
                group.add(orb);
                
                return group;
            },

            // === Crystal Golem (Level 13) ===
            'crystal-golem': function() {
                const group = new THREE.Group();
                const crystalPurple = 0xaa44ff;
                const crystalPink = 0xff4488;
                const crystalBlue = 0x44aaff;
                const crystalGreen = 0x44ff88;
                const darkCrystal = 0x3a2a5a;
                
                // Chunky torso
                const torsoGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.5);
                const torsoMaterial = new THREE.MeshLambertMaterial({ color: crystalPurple });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 0.8;
                torso.rotation.y = Math.PI / 6;
                group.add(torso);
                
                // Crystal protrusions on torso
                const protrusionGeometry = new THREE.ConeGeometry(0.12, 0.35, 5);
                const protrusionMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                [[0.3, 1.1, 0.15, 0.3], [-0.25, 1.05, -0.1, -0.4], [0.15, 0.95, -0.25, 0.5]].forEach(([x, y, z, rotZ]) => {
                    const protrusion = new THREE.Mesh(protrusionGeometry, protrusionMaterial);
                    protrusion.position.set(x, y, z);
                    protrusion.rotation.z = rotZ;
                    group.add(protrusion);
                });
                
                // Angular head (faceted)
                const headGeometry = new THREE.OctahedronGeometry(0.35, 0);
                const headMaterial = new THREE.MeshLambertMaterial({ color: crystalPurple });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.45;
                head.rotation.y = Math.PI / 4;
                group.add(head);
                
                // Glowing crystal eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: crystalBlue });
                const eyeGeometry = new THREE.OctahedronGeometry(0.08, 0);
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.48, 0.28);
                    group.add(eye);
                });
                
                // Crystal spike crown
                const spikeGeometry = new THREE.ConeGeometry(0.06, 0.25, 4);
                const spikeMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                [[0, 1.75, 0], [-0.15, 1.68, 0.1], [0.15, 1.68, -0.1], [0.1, 1.65, 0.15]].forEach(([x, y, z]) => {
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    spike.position.set(x, y, z);
                    group.add(spike);
                });
                
                // Chunky arms
                const armGeometry = new THREE.BoxGeometry(0.25, 0.5, 0.2);
                const armMaterial = new THREE.MeshLambertMaterial({ color: darkCrystal });
                [-0.55, 0.55].forEach((x, i) => {
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.set(x, 0.7, 0);
                    arm.rotation.z = i === 0 ? 0.3 : -0.3;
                    group.add(arm);
                });
                
                // Crystal claw hands
                const clawGeometry = new THREE.ConeGeometry(0.06, 0.3, 4);
                const clawMaterial = new THREE.MeshBasicMaterial({ color: crystalGreen });
                [[-0.6, 0.35, 0.1], [-0.7, 0.38, 0], [-0.6, 0.35, -0.1]].forEach(([x, y, z]) => {
                    const claw = new THREE.Mesh(clawGeometry, clawMaterial);
                    claw.position.set(x, y, z);
                    claw.rotation.z = Math.PI / 2 + 0.3;
                    group.add(claw);
                });
                [[0.6, 0.35, 0.1], [0.7, 0.38, 0], [0.6, 0.35, -0.1]].forEach(([x, y, z]) => {
                    const claw = new THREE.Mesh(clawGeometry, clawMaterial);
                    claw.position.set(x, y, z);
                    claw.rotation.z = -Math.PI / 2 - 0.3;
                    group.add(claw);
                });
                
                return group;
            },

            // === Gem Specter (Level 13) ===
            'gem-specter': function() {
                const group = new THREE.Group();
                const crystalPurple = 0xaa44ff;
                const crystalPink = 0xff4488;
                const crystalBlue = 0x44aaff;
                const spectralWhite = 0xccddff;
                
                // Large crystal shell
                const shellGeometry = new THREE.OctahedronGeometry(0.8, 0);
                const shellMaterial = new THREE.MeshLambertMaterial({ 
                    color: crystalPurple, 
                    transparent: true, 
                    opacity: 0.6 
                });
                const shell = new THREE.Mesh(shellGeometry, shellMaterial);
                shell.position.y = 1.3;
                shell.rotation.y = Math.PI / 4;
                group.add(shell);
                
                // Inner core
                const coreGeometry = new THREE.OctahedronGeometry(0.45, 0);
                const coreMaterial = new THREE.MeshBasicMaterial({ 
                    color: crystalBlue, 
                    transparent: true, 
                    opacity: 0.5 
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 1.3;
                core.rotation.y = Math.PI / 6;
                group.add(core);
                
                // Ghostly face inside
                const faceGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const faceMaterial = new THREE.MeshBasicMaterial({ 
                    color: spectralWhite, 
                    transparent: true, 
                    opacity: 0.7 
                });
                const face = new THREE.Mesh(faceGeometry, faceMaterial);
                face.position.y = 1.45;
                face.scale.set(1.0, 1.2, 0.9);
                group.add(face);
                
                // Eerie glowing eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                const eyeGeometry = new THREE.SphereGeometry(0.08, 12, 12);
                [-0.1, 0.1].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 1.5, 0.25);
                    group.add(eye);
                });
                
                // Dark mouth void
                const mouthGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x220022 });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.35, 0.28);
                mouth.scale.set(1.5, 0.8, 1);
                group.add(mouth);
                
                // Crystal spikes protruding from shell
                const spikeGeometry = new THREE.ConeGeometry(0.1, 0.5, 5);
                const spikeMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                [
                    [0, 2.2, 0, 0, 0],
                    [0.7, 1.3, 0, 0, -Math.PI/2],
                    [-0.7, 1.3, 0, 0, Math.PI/2],
                    [0, 1.3, 0.7, Math.PI/2, 0],
                    [0, 1.3, -0.7, -Math.PI/2, 0],
                    [0, 0.4, 0, Math.PI, 0]
                ].forEach(([x, y, z, rotX, rotZ]) => {
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    spike.position.set(x, y, z);
                    spike.rotation.x = rotX;
                    spike.rotation.z = rotZ;
                    group.add(spike);
                });
                
                return group;
            },

            // === Crystal Giant (Level 13) ===
            'crystal-giant': function() {
                const group = new THREE.Group();
                const amethystPurple = 0x9944ff;
                const crystalPink = 0xff4488;
                const crystalBlue = 0x44aaff;
                const lightAmethyst = 0xcc77ff;
                const darkCrystal = 0x3a2a5a;
                
                // Massive torso
                const torsoGeometry = new THREE.BoxGeometry(1.8, 2.0, 1.4);
                const torsoMaterial = new THREE.MeshLambertMaterial({ color: amethystPurple });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 3.5;
                torso.rotation.y = Math.PI / 8;
                group.add(torso);
                
                // Crystal spike protrusions
                const spikeGeometry = new THREE.ConeGeometry(0.25, 0.8, 5);
                const spikeMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                [
                    [0.8, 4.5, 0.4, 0.4],
                    [-0.7, 4.4, 0.3, -0.5],
                    [0.4, 4.6, -0.5, 0.2],
                    [-0.3, 4.7, -0.6, -0.2],
                    [0.9, 4.2, -0.3, 0.6],
                    [-0.85, 4.3, -0.2, -0.6]
                ].forEach(([x, y, z, rotZ]) => {
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    spike.position.set(x, y, z);
                    spike.rotation.z = rotZ;
                    group.add(spike);
                });
                
                // Chest plate crystal
                const chestGeometry = new THREE.OctahedronGeometry(0.6, 0);
                const chestMaterial = new THREE.MeshBasicMaterial({ color: lightAmethyst });
                const chest = new THREE.Mesh(chestGeometry, chestMaterial);
                chest.position.set(0, 3.5, 0.75);
                chest.rotation.y = Math.PI / 4;
                chest.scale.set(1, 1.2, 0.5);
                group.add(chest);
                
                // Massive faceted head
                const headGeometry = new THREE.OctahedronGeometry(0.7, 0);
                const headMaterial = new THREE.MeshLambertMaterial({ color: amethystPurple });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 5.2;
                head.rotation.y = Math.PI / 4;
                head.scale.set(1, 1.3, 0.9);
                group.add(head);
                
                // Glowing crystal eyes
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: crystalBlue });
                const eyeGeometry = new THREE.OctahedronGeometry(0.18, 0);
                [-0.25, 0.25].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(x, 5.3, 0.55);
                    group.add(eye);
                });
                
                // Crown spikes
                const crownGeometry = new THREE.ConeGeometry(0.15, 0.6, 4);
                const crownMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                [[0, 5.9, 0], [-0.35, 5.7, 0.2], [0.35, 5.7, -0.2], [0.2, 5.65, 0.35], [-0.2, 5.65, -0.35]].forEach(([x, y, z]) => {
                    const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                    crown.position.set(x, y, z);
                    group.add(crown);
                });
                
                // Massive arms
                const upperArmGeometry = new THREE.BoxGeometry(0.7, 1.4, 0.6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: darkCrystal });
                [-1.2, 1.2].forEach((x, i) => {
                    const arm = new THREE.Mesh(upperArmGeometry, armMaterial);
                    arm.position.set(x, 3.2, 0);
                    arm.rotation.z = i === 0 ? 0.2 : -0.2;
                    group.add(arm);
                });
                
                // Fist accents
                const fistGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.5);
                const fistMaterial = new THREE.MeshLambertMaterial({ color: amethystPurple });
                [-1.4, 1.4].forEach(x => {
                    const fist = new THREE.Mesh(fistGeometry, fistMaterial);
                    fist.position.set(x, 2.2, 0);
                    group.add(fist);
                });
                
                // Legs
                const legGeometry = new THREE.BoxGeometry(0.6, 1.8, 0.5);
                const legMaterial = new THREE.MeshLambertMaterial({ color: darkCrystal });
                [-0.5, 0.5].forEach(x => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 1.0, 0);
                    group.add(leg);
                });
                
                return group;
            },

            // === Crystal Dragon (Level 13 Boss) ===
            'crystal-dragon': function() {
                const group = new THREE.Group();
                const crystalPurple = 0xaa44ff;
                const crystalPink = 0xff4488;
                const crystalBlue = 0x44aaff;
                const deepPurple = 0x5a3a7a;
                const crystalWhite = 0xeeddff;
                
                // Long body
                const bodyGeometry = new THREE.CylinderGeometry(2.2, 2.8, 12, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: crystalPurple });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                body.position.x = 5;
                group.add(body);
                
                // Crystal scales along body
                const scaleGeometry = new THREE.OctahedronGeometry(0.8, 0);
                const scaleMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                for (let i = 0; i < 10; i++) {
                    const scale = new THREE.Mesh(scaleGeometry, scaleMaterial);
                    scale.position.set(i * 1.0, 3.2, 0);
                    scale.rotation.y = Math.PI / 4;
                    scale.scale.set(0.8, 1.2, 0.6);
                    group.add(scale);
                }
                
                // Neck
                const neckGeometry = new THREE.CylinderGeometry(1.8, 2.2, 5, 6);
                const neckMaterial = new THREE.MeshLambertMaterial({ color: deepPurple });
                const neck = new THREE.Mesh(neckGeometry, neckMaterial);
                neck.rotation.z = Math.PI / 2 + 0.3;
                neck.position.x = 12;
                neck.position.y = 2;
                group.add(neck);
                
                // Large faceted head
                const headGeometry = new THREE.OctahedronGeometry(3, 0);
                const headMaterial = new THREE.MeshLambertMaterial({ color: crystalPurple });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.x = 15;
                head.position.y = 3;
                head.rotation.z = -0.3;
                head.rotation.y = Math.PI / 4;
                head.scale.set(1.2, 1, 1.5);
                group.add(head);
                
                // Jaw
                const jawGeometry = new THREE.OctahedronGeometry(1.5, 0);
                const jaw = new THREE.Mesh(jawGeometry, headMaterial);
                jaw.position.set(17, 1.5, 0);
                jaw.rotation.y = Math.PI / 4;
                jaw.scale.set(1.5, 0.5, 1);
                group.add(jaw);
                
                // Crystal fangs
                const toothGeometry = new THREE.ConeGeometry(0.2, 0.8, 4);
                const toothMaterial = new THREE.MeshBasicMaterial({ color: crystalWhite });
                for (let i = 0; i < 6; i++) {
                    const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                    tooth.position.set(16.5 + (i % 2) * 0.6, 2, -1.0 + i * 0.4);
                    tooth.rotation.z = Math.PI;
                    group.add(tooth);
                }
                
                // Glowing crystal eyes
                const eyeGeometry = new THREE.OctahedronGeometry(0.8, 0);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: crystalBlue });
                [-1.5, 1.5].forEach(z => {
                    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    eye.position.set(15.5, 4, z);
                    eye.rotation.y = Math.PI / 4;
                    group.add(eye);
                });
                
                // Crown horns
                const hornGeometry = new THREE.ConeGeometry(0.5, 2.5, 5);
                const hornMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                [-2, 2].forEach(z => {
                    const horn = new THREE.Mesh(hornGeometry, hornMaterial);
                    horn.position.set(14, 5.5, z);
                    horn.rotation.x = z > 0 ? 0.3 : -0.3;
                    group.add(horn);
                });
                
                // Wings - crystal membrane frames
                [-1, 1].forEach(side => {
                    const wingGeometry = new THREE.BoxGeometry(0.3, 8, 4);
                    const wingMaterial = new THREE.MeshLambertMaterial({ 
                        color: crystalPurple, 
                        transparent: true, 
                        opacity: 0.7 
                    });
                    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                    wing.position.set(5, 4, side * 5);
                    wing.rotation.x = side * 0.3;
                    group.add(wing);
                });
                
                // Tail
                const tailGeometry = new THREE.ConeGeometry(1.5, 5, 6);
                const tailMaterial = new THREE.MeshLambertMaterial({ color: deepPurple });
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.rotation.z = -Math.PI / 2;
                tail.position.set(-3, 0, 0);
                group.add(tail);
                
                // Tail spike
                const tailSpikeGeometry = new THREE.OctahedronGeometry(1.2, 0);
                const tailSpikeMaterial = new THREE.MeshBasicMaterial({ color: crystalPink });
                const tailSpike = new THREE.Mesh(tailSpikeGeometry, tailSpikeMaterial);
                tailSpike.position.set(-5.5, 0, 0);
                tailSpike.rotation.y = Math.PI / 4;
                group.add(tailSpike);
                
                return group;
            }
        };

        // ========== RENDER SETUP ==========
        const scene = new THREE.Scene();
        scene.background = null; // Transparent

        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            preserveDrawingBuffer: true 
        });
        renderer.setSize(256, 256);
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambient = new THREE.AmbientLight(0x666666);
        scene.add(ambient);

        const directional = new THREE.DirectionalLight(0xffffff, 1);
        directional.position.set(5, 10, 5);
        scene.add(directional);

        const fill = new THREE.DirectionalLight(0x4488ff, 0.3);
        fill.position.set(-5, 5, -5);
        scene.add(fill);

        // Render the requested entity
        if (entityRenderers[entityId]) {
            const group = entityRenderers[entityId]();
            scene.add(group);

            // Auto-center and scale
            const box = new THREE.Box3().setFromObject(group);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            group.position.sub(center);
            group.position.y += size.y / 2;

            const scale = 3.5 / maxDim;
            if (maxDim > 3.5) {
                group.scale.multiplyScalar(scale);
            }

            camera.position.set(6, 4, 8);
            camera.lookAt(0, size.y * Math.min(scale, 1) / 2, 0);

            renderer.render(scene, camera);
        }

        // Signal completion
        const marker = document.createElement('div');
        marker.id = 'render-complete';
        document.body.appendChild(marker);
    </script>
</body>
</html>
